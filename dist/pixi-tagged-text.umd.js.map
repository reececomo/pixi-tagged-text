{"version":3,"file":"pixi-tagged-text.umd.js","sources":["../src/types.ts","../src/functionalUtils.ts","../src/errorMessaging.ts","../src/tags.ts","../src/defaultStyle.ts","../src/stringUtil.ts","../src/style.ts","../src/pixiUtils.ts","../src/layout.ts","../src/defaultOptions.ts","../src/TaggedText.ts","../node_modules/emoji-regex/es2015/RGI_Emoji.js"],"sourcesContent":["import * as PIXI from \"pixi.js\";\nimport TaggedText from \"./TaggedText\";\nimport { complement, flatEvery } from \"./functionalUtils\";\nimport { logWarning } from \"./errorMessaging\";\n\n///// GENERAL PURPOSE\n\nexport type Point = {\n  x: number;\n  y: number;\n};\nexport type Rectangle = Point & {\n  width: number;\n  height: number;\n};\n\nexport type Bounds = Rectangle;\n\nexport type Nested<T> = T | Array<Nested<T>>;\n\n///// OPTIONS\n\nexport type SpriteSource =\n  | string\n  | PIXI.Texture\n  | HTMLCanvasElement\n  | HTMLVideoElement;\n\nexport type TextureSource =\n  | string\n  | HTMLImageElement\n  | HTMLCanvasElement\n  | HTMLVideoElement\n  | PIXI.BaseTexture;\n\nexport type ImageSource = PIXI.Container | SpriteSource | TextureSource;\n\nexport const isSpriteSource = (s: ImageSource): s is SpriteSource =>\n  typeof s === \"string\" ||\n  s instanceof PIXI.Texture ||\n  s instanceof HTMLCanvasElement ||\n  s instanceof HTMLVideoElement;\nexport const isBaseTexture = (s: ImageSource): s is PIXI.BaseTexture =>\n  s instanceof PIXI.BaseTexture;\nexport const isImageElement = (s: ImageSource): s is HTMLImageElement =>\n  s instanceof HTMLImageElement;\nexport const isTextureSource = (s: ImageSource): s is TextureSource =>\n  isImageElement(s) || isBaseTexture(s);\n\nexport type FontProperty = string | number;\nexport type FontMap = Record<string, FontProperty>;\n\nexport type ImageSourceMap = Record<string, ImageSource>;\nexport type ImageMap = Record<string, PIXI.Container>;\n\nexport type SplitStyle = \"words\" | \"characters\";\n\nexport type ErrorMessageType = \"warning\" | \"error\";\nexport interface ErrorMessage {\n  type: ErrorMessageType;\n  code: string;\n  message: string;\n  target?: TaggedText;\n}\nexport type ErrorHandler = (e: ErrorMessage) => void;\n\nexport interface IFontMetrics {\n  ascent: number;\n  descent: number;\n  fontSize: number;\n}\n\nexport interface TaggedTextOptions {\n  debug?: boolean;\n  debugConsole?: boolean;\n  splitStyle?: SplitStyle;\n  adjustFontBaseline?: FontMap;\n  imgMap?: ImageSourceMap;\n  scaleIcons?: boolean;\n  skipUpdates?: boolean;\n  skipDraw?: boolean;\n  drawWhitespace?: boolean;\n  wrapEmoji?: boolean;\n  errorHandler?: ErrorHandler;\n  supressConsole?: boolean;\n  overdrawDecorations?: number;\n}\n\n///// STYLE PROPERTIES\n\n// PROPERTY NAMES\nexport const IMG_REFERENCE_PROPERTY = \"imgSrc\";\nexport const IMG_DISPLAY_PROPERTY = \"imgDisplay\";\nexport const DEFAULT_KEY = \"default\";\n\nexport enum MeasurementUnit {\n  default = \"px\",\n  px = \"px\",\n  em = \"em\",\n  rem = \"rem\",\n  pt = \"pt\",\n  pc = \"pc\",\n  in = \"in\",\n  cm = \"cm\",\n  mm = \"mm\",\n  percent = \"%\",\n  unknown = \"unknown\",\n}\n\nexport const DEFAULT_MEASUREMENT_UNIT: MeasurementUnit =\n  MeasurementUnit.default;\n\nexport interface MeasurementComponents {\n  value: number;\n  unit: MeasurementUnit;\n}\n\nexport type MeasurementValue = string | number;\n\nexport type Thickness = number;\nexport type Color = string | number;\nexport type FontSize = MeasurementValue;\nexport type Fill = Color | string[] | number[] | CanvasGradient | CanvasPattern;\nexport type VAlign = \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\nexport type AlignClassic = \"left\" | \"right\" | \"center\" | \"justify\";\nexport type Align =\n  | AlignClassic\n  | \"justify\"\n  | \"justify-left\"\n  | \"justify-right\"\n  | \"justify-center\"\n  | \"justify-all\";\nexport type ImageDisplayMode = \"icon\" | \"block\" | \"inline\";\nexport type ImageReference = string;\nexport type ImageDimensionPercentage = string;\nexport type ImageDimension = number | string | ImageDimensionPercentage;\nexport type TextTransform = \"normal\" | \"capitalize\" | \"uppercase\" | \"lowercase\";\nexport type FontStyle = \"normal\" | \"italic\" | \"oblique\";\nexport type TextDecorationValue = \"underline\" | \"overline\" | \"line-through\";\nexport type TextDecoration =\n  | \"normal\"\n  | TextDecorationValue\n  | `${TextDecorationValue} ${TextDecorationValue}`\n  | `${TextDecorationValue} ${TextDecorationValue} ${TextDecorationValue}`;\n\nexport interface ImageStyles {\n  [IMG_REFERENCE_PROPERTY]?: ImageReference;\n  [IMG_DISPLAY_PROPERTY]?: ImageDisplayMode;\n  imgScale?: ImageDimensionPercentage;\n  imgScaleX?: ImageDimensionPercentage;\n  imgScaleY?: ImageDimensionPercentage;\n  imgWidth?: ImageDimension;\n  imgHeight?: ImageDimension;\n  iconScale?: number;\n}\n\nexport interface UnderlineStyle {\n  underlineColor?: Color;\n  underlineThickness?: Thickness;\n  underlineOffset?: number;\n}\nexport interface OverlineStyle {\n  overlineColor?: Color;\n  overlineThickness?: Thickness;\n  overlineOffset?: number;\n}\nexport interface LineThroughStyle {\n  lineThroughColor?: Color;\n  lineThroughThickness?: Thickness;\n  lineThroughOffset?: number;\n}\n\nexport interface TextDecorationStyles\n  extends UnderlineStyle,\n    OverlineStyle,\n    LineThroughStyle {\n  textDecoration?: TextDecoration;\n}\n\nexport interface VerticalAlignStyles {\n  valign?: VAlign;\n}\n\nexport interface VerticalSpacingStyles {\n  lineSpacing?: number;\n  paragraphSpacing?: number;\n  adjustBaseline?: number;\n}\nexport interface FontScaleStyles {\n  fontScaleWidth?: number;\n  fontScaleHeight?: number;\n}\nexport interface TextTransformStyles {\n  textTransform?: TextTransform;\n}\n\nexport interface LineBreakStyles {\n  breakLines?: boolean;\n}\n\nexport interface TextStyleExtended\n  extends Record<string, unknown>,\n    Partial<Omit<PIXI.ITextStyle, \"align\">>,\n    ImageStyles,\n    TextDecorationStyles,\n    VerticalAlignStyles,\n    VerticalSpacingStyles,\n    FontScaleStyles,\n    TextTransformStyles,\n    LineBreakStyles {\n  // Overridden properties\n  align?: Align;\n  fontStyle?: FontStyle;\n  fontSize?: FontSize;\n  // alias for `fill`\n  color?: PIXI.TextStyleFill;\n}\n\nexport interface TextDecorationMetrics {\n  color: Color;\n  bounds: Bounds;\n}\n\nexport type TextStyleSet = Record<string, TextStyleExtended>;\n\n///// TAG PARSING\n\ntype TagName = string;\ntype AttributeName = string;\ntype AttributeValue = string | number;\nexport type AttributesList = Record<AttributeName, AttributeValue>;\nexport interface TagWithAttributes {\n  tagName: string;\n  attributes: AttributesList;\n}\n\nexport interface TagMatchData extends TagWithAttributes {\n  tag: string;\n  isOpening: boolean;\n  index: number;\n}\nexport type TagStack = TagMatchData[];\n\n///// PARSED TOKENS\n\nexport type NewlineToken = \"\\n\";\nexport type WhitespaceToken = \" \" | \"\\t\" | NewlineToken;\nexport type TextToken = string;\nexport type SpriteToken = PIXI.Sprite;\nexport type ContainerToken = PIXI.Container;\n\nexport interface CompositeToken<T extends Token = Token> {\n  children: T[];\n}\n\nexport type Token = TextToken | CompositeToken | SpriteToken | ContainerToken;\nexport type Tokens = CompositeToken;\n\nexport interface TagToken extends CompositeToken<TagToken | TextToken> {\n  tag?: TagName;\n  attributes?: AttributesList;\n}\nexport type TagTokens = TagToken;\n\nexport interface StyledToken\n  extends CompositeToken<StyledToken | TextToken | SpriteToken | ContainerToken> {\n  style: TextStyleExtended;\n  tags: string;\n}\n\nexport type StyledTokens = StyledToken;\n\n// About Tokens\n// The contents of a block of text are composed of nested tokens in 4 layers.\n// The types are:\n// Paragraph - contains Lines\n// Lines - contains words Words\n// Word - contains Segments\n// Segment - contains text or image content, styles, and other metadata.\n//\n// Notes:\n// - The SegmentToken is the only one that contains text content and metadata;\n//   the rest are all ordered containers used to organize the smaller pieces inside it.\n//   In other words, the type of a ParagraphToken is equal to SegmentToken[][][]\n// - The .tokens property of a TaggedText is a ParagraphToken.\n// - ParagrahpTokens don't necessarily contain paragraphs in the grammatical sense.\n//   It is simply a collection of lines of text and could contain one literal paragraph,\n//   or more than one, or none at all. Same is true for Lines & Words\n// - Segments are groups of 1 or more individual characters (or sometimes sprites).\n//   Most WordTokens contain only one Segment, however, each time styles change\n//   in the text, a new segment is crated, therefore, some words will have multiple\n//   segments if they contain tags within like \"Abso<i>lutely</i>\".\n// - When splitStyle is \"characters\", each character gets its own SegmentToken.\n\nexport type SegmentContent = TextToken | SpriteToken | ContainerToken;\nexport interface SegmentToken {\n  content: SegmentContent;\n  bounds: Rectangle;\n  fontProperties: IFontMetrics;\n  style: TextStyleExtended;\n  tags: string;\n  textDecorations?: TextDecorationMetrics[];\n}\nexport type WordToken = SegmentToken[];\nexport type LineToken = WordToken[];\nexport type ParagraphToken = LineToken[];\n\nexport const createEmptySegmentToken = (): SegmentToken => ({\n  content: \"\",\n  bounds: new PIXI.Rectangle(),\n  fontProperties: { ascent: 0, descent: 0, fontSize: 0 },\n  style: {},\n  tags: \"\",\n  textDecorations: [],\n});\n\nexport interface SpriteSegmentToken extends SegmentToken {\n  content: SpriteToken;\n}\nexport interface TextSegmentToken extends SegmentToken {\n  content: TextToken;\n}\n\nexport interface WhitespaceSegmentToken extends TextSegmentToken {\n  content: WhitespaceToken;\n}\nexport interface NewlineSegmentToken extends TextSegmentToken {\n  content: NewlineToken;\n}\n\nexport const isWhitespace = (s: string): s is WhitespaceToken =>\n  s !== \"\" &&\n  s.split(\"\").every((char: string): boolean => char.search(/\\s/) === 0);\nexport const isNewline = (s: string): s is NewlineToken =>\n  isWhitespace(s) && s === \"\\n\";\n\nexport const _isSpriteToken = (t: SegmentToken): t is SpriteSegmentToken =>\n  t.content instanceof PIXI.Sprite;\nexport const isSpriteToken = flatEvery(_isSpriteToken);\n\nexport const _isTextToken = (t: SegmentToken): t is TextSegmentToken =>\n  typeof t.content === \"string\";\nexport const isTextToken = flatEvery(_isTextToken);\n\nexport const _isWhitespaceToken = (\n  t: SegmentToken\n): t is WhitespaceSegmentToken =>\n  t !== undefined && _isTextToken(t) && isWhitespace(t.content);\nexport const isWhitespaceToken = flatEvery(_isWhitespaceToken);\n\nexport const _isNewlineToken = (t: SegmentToken): t is NewlineSegmentToken =>\n  t !== undefined && _isTextToken(t) && isNewline(t.content);\nexport const isNewlineToken = (t?: Nested<SegmentToken>): boolean =>\n  t === undefined ? false : flatEvery(_isNewlineToken)(t);\n\nexport const isNotWhitespaceToken = complement(isWhitespaceToken);\n\nexport const isEmptyObject = <T>(a: T): boolean =>\n  a instanceof Object && Object.keys(a).length === 0;\n\nexport const isPixel = (s: string): boolean => s.trim().endsWith(\"px\");\n\nexport const isEm = (s: string): boolean => s.trim().endsWith(\"em\");\n\nexport const isPercent = (s: string): boolean => s.trim().endsWith(\"%\");\n\nexport const pixelToNumber = (s: string): number =>\n  Number(s.trim().slice(0, -2));\nexport const emToNumber = pixelToNumber;\n\nexport const percentStringToNumber = (s: string): number =>\n  isPercent(s) ? Number(s.trim().slice(0, -1)) / 100 : NaN;\n\nexport const measurementValueToComponents = (\n  input: MeasurementValue\n): MeasurementComponents => {\n  if (input === undefined) {\n    throw new Error(\"value is undefined!\");\n  }\n\n  if (typeof input === \"number\") {\n    return { value: input, unit: DEFAULT_MEASUREMENT_UNIT };\n  }\n  input = input.trim();\n\n  const pattern = new RegExp(Object.values(MeasurementUnit).join(\"|\") + \"$\");\n  const i = input.search(pattern);\n  if (i !== -1) {\n    return {\n      value: parseFloat(input.slice(0, i)),\n      unit: input.slice(i) as MeasurementUnit,\n    };\n  }\n\n  const isAllDigits = input.search(/^[\\d.]+$/) === 0;\n  if (isAllDigits) {\n    const forcedNumberConversion = parseFloat(input);\n    if (isNaN(forcedNumberConversion) === false) {\n      return { value: parseFloat(input), unit: DEFAULT_MEASUREMENT_UNIT };\n    }\n  }\n\n  // TOOD: hook into errorHandler\n  logWarning()(\n    \"invalid-units\",\n    `${input} is not a valid measurement value. Please use one of the following units: ${Object.keys(\n      MeasurementUnit\n    ).join(\", \")}`\n  );\n\n  return { value: NaN, unit: MeasurementUnit.unknown };\n};\n","import { Nested } from \"./types\";\n\n/**\n * a -> boolean\n */\ntype Predicate<T> = (t: T) => boolean;\n\nexport const combineRecords = <\n  A extends Record<string, unknown>,\n  B extends Record<string, unknown> = A\n>(\n  a: A,\n  b: B\n): A & B => ({\n  ...a,\n  ...b,\n});\n\n/**\n * Returns the first item in a list. AKA head\n * List a -> a\n */\nexport const first = <T>(a: T[]): T => a[0];\n\n/**\n * Return the last item in a list. Aka tail\n * List f => f a -> a\n */\nexport const last = <T>(a: T[]): T => a[a.length - 1];\n\nexport const isDefined: Predicate<unknown | undefined> = (a): boolean =>\n  a !== undefined;\n\n/**\n * Predicate p => p -> p\n */\nexport const complement =\n  <T>(predicate: Predicate<T>) =>\n  (input: T): boolean =>\n    !predicate(input);\n\n/**\n * List f => string -> f {string: a} -> f a\n */\nexport const pluck =\n  <T, U>(key: keyof U) =>\n  (objects: U[]): T[] =>\n    (objects as (U & Record<string, T>)[]).map<T>((o) => o[key]);\n\nexport const assoc =\n  <T extends Record<string, U>, U>(key: keyof T) =>\n  (value: U) =>\n  (object: T): T => ({\n    ...object,\n    ...{ [key]: value },\n  });\n\n/**\n * Takes a key (k), a function (f) and an object (o) and applies f to the property k\n * of the object and stores the result in o[k].\n * Key k, Record r => k -> (a -> a) -> r k a -> r k a\n */\nexport const mapProp =\n  <T, U>(k: keyof U) =>\n  (f: (t: T) => T) =>\n  (o: U): U => ({\n    ...o,\n    [k]: f((o as U & Record<string, T>)[k]),\n  });\n\nexport const flatReduce =\n  <T, U>(f: (acc: U, t: T) => U, acc: U) =>\n  (nested: Nested<T>): U =>\n    // @ts-ignore-next-line\n    [nested].flat(255).reduce(f, acc);\n\ntype FlatReduceRetrun<T, U> = (nested: Nested<T>) => U;\n\nexport const flatEvery = <T>(p: Predicate<T>): FlatReduceRetrun<T, boolean> =>\n  flatReduce<T, boolean>((acc: boolean, t: T) => acc && p(t), true);\n\nexport const nestedMap =\n  <T, U>(f: (t: T) => U) =>\n  (nested: Nested<T>): Nested<U> =>\n    nested instanceof Array ? nested.map(nestedMap(f)) : f(nested);\n\n/**\n * Takes a list and a predicate and returns a number that represents the number of\n * true statements when applied to the elements in the list.\n * In other words, the number of elements that pass the test.\n * (a -> boolean) -> a[] -> number\n */\nexport const countIf =\n  <T>(p: Predicate<T>) =>\n  (a: Array<T>): number =>\n    a.reduce((count, item) => (p(item) ? count + 1 : count), 0);\n\nexport type Unary<Param, Return> = (p: Param) => Return;\n","import TaggedText from \"./TaggedText\";\nimport { ErrorHandler, ErrorMessage, ErrorMessageType } from \"./types\";\n\nconst log =\n  (type: ErrorMessageType) =>\n  (handler?: ErrorHandler, supressConsole = false, target?: TaggedText) =>\n  (code: string, message: string): void => {\n    if (supressConsole !== true) {\n      const method = type === \"warning\" ? console.warn : console.error;\n      method(`[${code}] ${message}`);\n    }\n    if (handler) {\n      handler({ target, code, message, type } as ErrorMessage);\n    }\n  };\n\nexport const logWarning = log(\"warning\");\nexport const logError = log(\"error\");\n","import getEmojiRegex from \"emoji-regex/es2015/RGI_Emoji\";\nimport { logWarning } from \"./errorMessaging\";\n\nimport { last } from \"./functionalUtils\";\nimport {\n  TagMatchData,\n  AttributesList,\n  TagWithAttributes,\n  CompositeToken,\n  TagToken,\n  TextToken,\n  isEmptyObject,\n} from \"./types\";\n\nconst defaultLogWarning = logWarning();\n\n// TODO: this can probably be just a static value without all the options and parameters.\n// Seems doing one pass will be enough to gather all relevant info.\n// TODO: support self closing tags?\n\n/**\n * Generates a regular expression object for identifying tags and attributes.\n * @param tagNamesToMatch List of tag-names that will be matched by the RegExp\n */\nexport const getTagRegex = (tagNamesToMatch: string[] = [\"\\\\w+\"]): RegExp => {\n  const matchingTagNames = tagNamesToMatch.join(\"|\");\n\n  const captureGroup = (a: string) => `(${a})`;\n  const noCaptureGroup = (a: string) => `(?:${a})`;\n\n  const WHITESPACE = `\\\\s`;\n  const S = WHITESPACE + \"*\";\n  const SS = WHITESPACE + \"+\";\n  const TAG_NAMES = captureGroup(matchingTagNames);\n  const NOT_CLOSING_TAG = `[^>]`;\n\n  const ATTRIBUTES =\n    captureGroup(noCaptureGroup(`${SS}${NOT_CLOSING_TAG}*`) + \"*\") + \"+\";\n  const TAG_OPEN = `<` + TAG_NAMES + ATTRIBUTES + S + `>`;\n  const TAG_CLOSE = `</${TAG_NAMES}${S}>`;\n\n  const pattern = `${TAG_OPEN}|${TAG_CLOSE}`;\n\n  return new RegExp(pattern, \"g\");\n};\n\nexport const EMOJI_TAG = \"__EMOJI__\";\n\n/**\n * Takes a string of attributes and returns an object with key value pairs for each attribute.\n * Converts \"true\" | \"false\" into booleans and number-like strings into numbers.\n * @param attributesString  XML style attributes like \"src='/image.png' alt='foo'\"\n */\nexport const parseAttributes = (attributesString = \"\"): AttributesList => {\n  if (attributesString === \"\") {\n    return {};\n  }\n\n  const attributeMatch = /[a-zA-Z][a-zA-Z0-9]*=('|\")[^'\"]*('|\")/g;\n\n  const attributes = attributesString.trim().match(attributeMatch);\n  if (attributes === null) {\n    throw new Error('Invalid attributes string: \"' + attributesString + '\"');\n  }\n\n  return [...attributes].reduce((obj: AttributesList, attribute: string) => {\n    const attributePair: string[] = [\n      attribute.substring(0, attribute.indexOf(\"=\")),\n      attribute.substring(attribute.indexOf(\"=\") + 1),\n    ];\n    const name = attributePair[0].trim();\n    const valueStr: string = attributePair[1]\n      .substring(1, attributePair[1].length - 1)\n      .trim();\n\n    obj[name] = valueStr;\n    return obj;\n  }, {});\n};\n\n/** Converts from RegExpExecArray to TagMatchData */\nexport const createTagMatchData = (match: RegExpExecArray): TagMatchData => {\n  const {\n    0: tag,\n    1: openTagName,\n    2: attributes,\n    3: closeTagName,\n    index,\n  } = match;\n  const tagName = openTagName ?? closeTagName;\n  const isOpening = openTagName !== undefined;\n  return {\n    tag,\n    tagName,\n    isOpening,\n    attributes: parseAttributes(attributes),\n    index,\n  };\n};\n\n/** Converts TagMatchData to TagWithAttributes */\nexport const tagMatchDataToTagWithAttributes = (\n  tag: TagMatchData\n): TagWithAttributes => ({\n  tagName: tag.tagName,\n  attributes: tag.attributes,\n});\n\n/**\n * Splits original text into an untagged list of string segments.\n * @param input Original text input\n * @param tagMatchData Results of regexp exect converted to tag matches.\n */\nexport const extractSegments = (\n  input: string,\n  tagMatchData: TagMatchData[]\n): string[] => {\n  const segments: string[] = [];\n\n  let remaining = input;\n  let offset = 0;\n  let tagMatch: TagMatchData;\n  for (tagMatch of tagMatchData) {\n    if (remaining !== undefined) {\n      const { tag, index } = tagMatch;\n      const startOfTag = index - offset;\n      const endOfTag = startOfTag + tag.length;\n      offset += endOfTag;\n\n      const segment = remaining.substr(0, startOfTag);\n      segments.push(segment);\n\n      remaining = remaining.substr(endOfTag);\n    }\n  }\n  segments.push(remaining);\n\n  return segments;\n};\n\nconst selfClosingTagSearch = (() => {\n  const group = (s: string) => `(${s})`;\n  const any = (s: string) => s + `*`;\n  const not = (...s: string[]) => `[^${s.join(\"\")}]`;\n  const WORD_START = `[A-Za-z_]`;\n  const WORD = `[A-Za-z0-9_]`;\n  const TAG_OPEN = `<`;\n  const TAG_SLASH = `/`;\n  const TAG_CLOSE = `>`;\n  const TAG_SELF_CLOSE = TAG_SLASH + TAG_CLOSE;\n\n  return new RegExp(\n    TAG_OPEN +\n      // tag group\n      group(WORD_START + any(WORD)) +\n      // attribute group\n      group(any(not(TAG_SLASH, TAG_CLOSE))) +\n      TAG_SELF_CLOSE,\n    `g`\n  );\n})();\n\nexport const wrapEmoji = (input: string): string => {\n  const emojiRegex = new RegExp(\n    `((<|</)[^>]*)?(${getEmojiRegex().source})+`,\n    \"gum\"\n  );\n\n  return input.replaceAll(emojiRegex, (match, tagStart) => {\n    if (tagStart?.length > 0) {\n      // if the emoji is inside a tag, ignore it.\n      return match;\n    }\n    return `<${EMOJI_TAG}>${match}</${EMOJI_TAG}>`;\n  });\n};\n\nexport const replaceSelfClosingTags = (input: string): string =>\n  input.replace(selfClosingTagSearch, (_, tag, attributes = \"\") => {\n    let output = `<${tag}${attributes}></${tag}>`;\n    output = output.replace(/\\s+/g, \" \");\n    output = output.replace(/\\s>/g, \">\");\n    return output;\n  });\n\n/**\n * Returns the string with the tags removed.\n * TODO: could be memoized but only used by untaggedText prop of TaggedText so probably not worth it.\n */\nexport const removeTags = (input: string): string =>\n  input.replace(getTagRegex(), \"\");\n\n// export const isTextToken = (token: Token): boolean => typeof token === \"string\";\n// export const isNewlineToken = (token: Token): boolean =>\n//   isWhitespaceToken(token) && token === \"\\n\";\n// export const isCompositeToken = (token: Token): boolean =>\n//   isTextToken(token) === false && \"children\" in (token as CompositeToken);\n\n// export const makeSpacesSeparateWords = (segment: string): string[] =>\n//   segment.replace(\" \", \"__SPACE__ __SPACE__\").split(\"__SPACE__\");\n\nexport const tagMatchToTagToken = (tag: TagMatchData): TagToken => {\n  return {\n    tag: tag.tagName,\n    children: [],\n\n    // Add attributes unless undefined\n    ...(isEmptyObject(tag.attributes) ? {} : { attributes: tag.attributes }),\n  };\n};\n\nexport const createTokensNew = (\n  segments: string[],\n  tags: TagMatchData[],\n  logWarningFunction = defaultLogWarning\n): (TagToken | TextToken)[] => {\n  const rootTokens: CompositeToken<TagToken | TextToken> = { children: [] };\n  if (segments[0] !== \"\") {\n    rootTokens.children.push(segments[0]);\n  }\n  // Track which tags are opened and closed and add them to the list.\n  const tokenStack: TagToken[] = [rootTokens];\n\n  for (let i = 0; i < tags.length; i++) {\n    const tag = tags[i];\n    const segment = segments[i + 1] ?? \"\";\n    if (tag.isOpening) {\n      const token = tagMatchToTagToken(tag);\n      if (segment !== \"\") {\n        token.children.push(segment);\n      }\n      last(tokenStack).children.push(token);\n      tokenStack.push(token as CompositeToken<TagToken | TextToken>);\n    } else {\n      const poppedToken = tokenStack.pop();\n      if (poppedToken === undefined || poppedToken.tag !== tag.tagName) {\n        throw new Error(\n          `Unexpected tag nesting. Found a closing tag \"${tag.tagName}\" that doesn't match the previously open tag \"${poppedToken?.tag}\"`\n        );\n      }\n      if (segment !== \"\") {\n        last(tokenStack).children.push(segment);\n      }\n    }\n  }\n  if (tokenStack.length > 1) {\n    logWarningFunction(\n      \"unclosed-tags\",\n      `Found ${tokenStack.length - 1} unclosed tags in\\n${tokenStack\n        .map((token) => token.tag)\n        .join(\"-\")}`\n    );\n  }\n\n  return rootTokens.children;\n};\n\nexport const containsEmoji = (input: string): boolean =>\n  getEmojiRegex().test(input);\n\n/**\n * Converts a string into a list of tokens that match segments of text with styles.\n *\n * @param input Input string with XML-style tags.\n * @param tagNamesToMatch Used to only tokenize tags that have styles defined for them.\n */\nexport const parseTagsNew = (\n  input: string,\n  tagNamesToMatch: string[] = [],\n  shouldWrapEmoji = false,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n  logWarningFunction = defaultLogWarning\n): CompositeToken<TagToken | TextToken> => {\n  // TODO: Warn the user if tags were found that are not defined in the tagStyles.\n\n  if (shouldWrapEmoji && containsEmoji(input)) {\n    input = wrapEmoji(input);\n  }\n\n  input = replaceSelfClosingTags(input);\n  const re = getTagRegex(tagNamesToMatch);\n  const matchesRaw: RegExpExecArray[] = [];\n  const tagMatches: TagMatchData[] = [];\n  let match;\n  while ((match = re.exec(input))) {\n    matchesRaw.push(match);\n\n    const tagMatch = createTagMatchData(match);\n    tagMatches.push(tagMatch);\n  }\n\n  const segments = extractSegments(input, tagMatches);\n\n  const tokens = createTokensNew(segments, tagMatches, logWarningFunction);\n\n  return { children: tokens };\n};\n","import { TextStyleExtended, IMG_DISPLAY_PROPERTY } from \"./types\";\nexport const DEFAULT_STYLE: TextStyleExtended = {\n  valign: \"baseline\",\n  dropShadowColor: 0x000000,\n  fill: 0x000000,\n  fontSize: 26,\n  stroke: 0x000000,\n  [IMG_DISPLAY_PROPERTY]: \"inline\",\n  wordWrap: true,\n  wordWrapWidth: 500,\n  iconScale: 1.0,\n  breakLines: true,\n};\nObject.freeze(DEFAULT_STYLE);\n\nexport default DEFAULT_STYLE;\n","// modified from: https://github.com/h26k2/capitalize-text/blob/master/index.js\nexport const capitalize = (str: string): string => {\n  const chars = str.split(\" \");\n  let converted = ``;\n\n  for (let i = 0; i < chars.length; i++) {\n    converted += `${chars[i].charAt(0).toUpperCase()}${chars[i].substr(1)} `;\n  }\n\n  return converted.trim();\n};\n\n// Returns true if the string is a number string otherwise false.\nexport const stringIsNumber = (s: string): boolean =>\n  s.trim().search(/^-?[0-9]*\\.?[0-9]+$/) === 0;\n\n// Returns true if the string is only whitespace and nothing else.\nexport const isOnlyWhitespace = (s: string): boolean => s.search(/^\\s+$/) === 0;\n","import { stringIsNumber } from \"./stringUtil\";\nimport { combineRecords, isDefined, pluck } from \"./functionalUtils\";\nimport {\n  AttributesList,\n  TagWithAttributes,\n  TextStyleExtended,\n  TextStyleSet,\n  IFontMetrics,\n  IMG_REFERENCE_PROPERTY,\n  ImageMap,\n  TextToken,\n  TagToken,\n  TagTokens,\n  StyledTokens,\n  StyledToken,\n  SpriteToken,\n  isEmptyObject,\n  TextDecorationValue,\n  Bounds,\n  TextDecorationMetrics,\n  Thickness,\n  Color,\n  FontSize,\n  measurementValueToComponents,\n  MeasurementUnit,\n  Align,\n  AlignClassic,\n  ContainerToken,\n} from \"./types\";\nimport { cloneSprite } from \"./pixiUtils\";\nimport * as PIXI from \"pixi.js\";\nimport DEFAULT_STYLE from \"./defaultStyle\";\n\n/**\n * Combine 2 styles into one.\n */\nexport const combineStyles: (\n  a: TextStyleExtended,\n  b: TextStyleExtended\n) => TextStyleExtended = combineRecords;\n\n/**\n * Combines multiple styles into one.\n * @param styles List of styles to combine.\n */\nexport const combineAllStyles = (\n  styles: (TextStyleExtended | undefined)[]\n): TextStyleExtended =>\n  (styles.filter(isDefined) as TextStyleExtended[]).reduce(combineStyles, {});\n\nexport const convertAttributeValues = (\n  attributes: AttributesList\n): AttributesList => {\n  const convertedAttributes: AttributesList = {};\n  for (const key in attributes) {\n    const value = attributes[key];\n    const isValueString = typeof value === \"string\";\n    const isStringNumber = isValueString && stringIsNumber(value);\n\n    if (isStringNumber) {\n      convertedAttributes[key] = parseFloat(value);\n    } else {\n      convertedAttributes[key] = value;\n    }\n  }\n  return convertedAttributes;\n};\n\n/**\n * Replaces properties of a TextStyle object with new values.\n * (Since AttributeLists are basically partially defined styles, this is the same as combineStyles)\n * @param attributes List of attributes to overwrite in the target style.\n * @param style The style to modify.\n */\nexport const injectAttributes = (\n  attributes: AttributesList = {},\n  style: TextStyleExtended = {}\n): TextStyleExtended | undefined => {\n  if (isEmptyObject(style) && isEmptyObject(attributes)) return undefined;\n  return combineRecords(style, convertAttributeValues(attributes));\n};\n\n/**\n * Looks up a tag in a list of tag styles (with optional attributes) and returns it.\n * @param tagName Tag name to check.\n * @param tagStyles Set of tag styles to search.\n * @param attributes Attributes to inject into the style (optional).\n */\nexport const getStyleForTag = (\n  tagName: string,\n  tagStyles: TextStyleSet,\n  attributes: AttributesList = {}\n): TextStyleExtended | undefined => {\n  const style = injectAttributes(attributes, tagStyles[tagName]) ?? {};\n  if (Object.values(style).length === 0) return undefined;\n  return style;\n};\n\n/**\n * Converts TagWithAttributes into a style object.\n * @param param0 A TagWithAttributes object that has a tag name matched with any optional attributes.\n * @param tagStyles Set of tag styles to search.\n */\nexport const tagWithAttributesToStyle = (\n  { tagName, attributes }: TagWithAttributes,\n  tagStyles: TextStyleSet\n): TextStyleExtended =>\n  getStyleForTag(tagName, tagStyles, attributes) as TextStyleExtended;\n\n/**\n * Gets styles for several tags and returns a single combined style object.\n * Results are cached for future requests.\n * @param tags Tags (with attribues) to look up.\n * @param tagStyles Set of tag styles to search.\n * @param styleCache An object that holds the cached values for the combined styles.\n * @returns\n */\nexport const getStyleForTags = (\n  tags: TagWithAttributes[],\n  tagStyles: TextStyleSet,\n  styleCache: TextStyleSet\n): TextStyleExtended => {\n  const tagHash = JSON.stringify(tags);\n  if (styleCache[tagHash] === undefined) {\n    const defaultStyle = tagStyles.default;\n    const styles = tags.map((tag) => tagWithAttributesToStyle(tag, tagStyles));\n    const stylesWithDefault = [defaultStyle, ...styles];\n    styleCache[tagHash] = combineAllStyles(stylesWithDefault);\n  }\n  return styleCache[tagHash];\n};\n\nexport const interpretFontSize = (\n  baseFontSize: FontSize,\n  fontSize: FontSize\n): FontSize => {\n  const { value: baseValue, unit: baseUnit } =\n    measurementValueToComponents(baseFontSize);\n  const { value, unit } = measurementValueToComponents(fontSize);\n\n  if (unit === MeasurementUnit.percent) {\n    const percentage = value / 100;\n    return baseValue * percentage + baseUnit;\n  }\n  return fontSize;\n};\n\nexport const mapTagsToStyles = (\n  tokens: TagTokens,\n  styles: TextStyleSet,\n  spriteTemplates?: ImageMap\n): StyledTokens => {\n  const defaultStyle: TextStyleExtended = styles.default ?? {};\n  const tagStack: TagWithAttributes[] = [];\n  const fontSizeStack: FontSize[] = [];\n  const styleCache = {};\n\n  const convertTagTokenToStyledToken = (\n    token: TagToken | TextToken\n  ): StyledToken | TextToken => {\n    if (typeof token === \"string\") {\n      return token as TextToken;\n    }\n\n    const { tag, attributes = {} } = token;\n    let style: TextStyleExtended = defaultStyle;\n    let tags = \"\";\n\n    const currentBaseFontSize =\n      fontSizeStack[fontSizeStack.length - 1] ?? DEFAULT_STYLE.fontSize;\n\n    if (tag) {\n      // Put the current tag on the stack.\n      tagStack.push({ tagName: tag, attributes });\n      // Get tag names as comma separates string\n      tags = pluck(\"tagName\")(tagStack).join(\",\");\n      // Merge all tags into a style object.\n      style = getStyleForTags(tagStack, styles, styleCache);\n      style = convertDecorationToLineProps(style);\n    }\n\n    if (style.fontSize !== undefined) {\n      style.fontSize = interpretFontSize(currentBaseFontSize, style.fontSize);\n    } else {\n      style.fontSize = currentBaseFontSize;\n    }\n\n    const currentTagStyle: TextStyleExtended = tag ? styles[tag] : {};\n    const currentTagColor = currentTagStyle.color;\n    const currentTagFill = currentTagStyle.fill;\n\n    // Use color as an alias for fill.\n    if (currentTagColor !== undefined && currentTagFill === undefined) {\n      style.fill = style.color;\n    }\n    style.color = style.fill;\n\n    fontSizeStack.push(style.fontSize as FontSize);\n\n    const styledToken: StyledToken = {\n      style,\n      tags,\n      children: token.children.map(convertTagTokenToStyledToken),\n    };\n\n    // If a matching sprite exits in the imgMap...\n    const imgKey = style[IMG_REFERENCE_PROPERTY] ?? \"\";\n    if (imgKey) {\n      if (spriteTemplates === undefined) {\n        throw new Error(\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but no imgMap was provided. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\n        );\n      }\n      const sprite: SpriteToken | ContainerToken | undefined = spriteTemplates[imgKey];\n      if (sprite === undefined) {\n        throw new Error(\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but there was no matching sprite in the sprite map. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\n        );\n      }\n      if (sprite instanceof PIXI.Container === false) {\n        throw new Error(\n          `The image reference you provided for \"${imgKey}\" is not a Container. The imgMap can only accept PIXI.Container instances.`\n        );\n      }\n\n      // insert sprite as first token.\n      styledToken.children = [sprite, ...styledToken.children];\n    }\n\n    // Remove the last tag from the stack\n    tagStack.pop();\n    fontSizeStack.pop();\n\n    return styledToken;\n  };\n\n  return convertTagTokenToStyledToken(tokens) as StyledTokens;\n};\n\nexport const convertDecorationToLineProps = (\n  style: TextStyleExtended\n): TextStyleExtended => {\n  const { textDecoration } = style;\n\n  if (textDecoration === undefined || textDecoration === \"normal\") {\n    return style;\n  }\n\n  const { decorationColor, decorationThickness } = style;\n  const defaultColor = decorationColor || style.fill || DEFAULT_STYLE.fill;\n  const defaultThickness = decorationThickness || 1;\n  const defaultOffset = 0;\n\n  function mergeDecoration(\n    decorationLineType: TextDecorationValue,\n    decorationLineTypeCamelCase: string = decorationLineType\n  ): Partial<TextStyleExtended> {\n    if (style.textDecoration?.includes(decorationLineType)) {\n      return {\n        [`${decorationLineTypeCamelCase}Color`]:\n          style[`${decorationLineTypeCamelCase}Color`] ?? defaultColor,\n        [`${decorationLineTypeCamelCase}Thickness`]:\n          style[`${decorationLineTypeCamelCase}Thickness`] ?? defaultThickness,\n        [`${decorationLineTypeCamelCase}Offset`]:\n          style[`${decorationLineTypeCamelCase}Offset`] ?? defaultOffset,\n      };\n    }\n    return {};\n  }\n\n  return {\n    ...style,\n    ...mergeDecoration(\"underline\"),\n    ...mergeDecoration(\"overline\"),\n    ...mergeDecoration(\"line-through\", \"lineThrough\"),\n  };\n};\n\nexport const extractDecorations = (\n  style: TextStyleExtended,\n  textBounds: Bounds,\n  fontProperties: IFontMetrics\n): TextDecorationMetrics[] => {\n  const { ascent, descent } = fontProperties;\n  const baseline = ascent;\n  const ascender = descent;\n  const xHeight = baseline - ascender;\n  const { width } = textBounds;\n  const x = 0;\n\n  function styleToMetrics(key: string): TextDecorationMetrics | undefined {\n    const color = style[`${key}Color`] as Color;\n    const height = style[`${key}Thickness`] as Thickness;\n    const offset = (style[`${key}Offset`] as number) ?? 0;\n\n    if (color === undefined || height === undefined) {\n      return undefined;\n    }\n\n    let y = offset;\n    if (key === \"underline\") {\n      // position underline below baseline\n      y += baseline + descent / 2;\n    } else if (key === \"lineThrough\") {\n      // position lineThrough in center of ascent\n      y += ascender + xHeight / 2;\n    }\n    // else, position overline at top of text\n\n    return {\n      color,\n      bounds: { x, y, width, height },\n    };\n  }\n\n  const keySuffices = [\"underline\", \"overline\", \"lineThrough\"];\n  const metrics = keySuffices\n    .map(styleToMetrics)\n    .filter((x) => x !== undefined) as TextDecorationMetrics[];\n  return metrics;\n};\n\nexport const convertUnsupportedAlignment = (\n  align?: Align\n): AlignClassic | undefined => {\n  if (align === undefined) {\n    return undefined;\n  }\n  switch (align) {\n    case \"justify\":\n    case \"justify-left\":\n    case \"justify-all\":\n      return \"left\";\n    case \"justify-center\":\n      return \"center\";\n    case \"justify-right\":\n      return \"right\";\n    default:\n      return align as AlignClassic;\n  }\n};\n","import * as PIXI from \"pixi.js\";\nimport { IFontMetrics } from \"./types\";\n\nconst PX_PER_EM = 16;\nconst PX_PER_PERCENT = 16 / 100;\nconst PX_PER_PT = 1.3281472327365;\n\nexport const measureFont = (context: { font: string }): IFontMetrics =>\n  PIXI.TextMetrics.measureFont(context.font);\n\nexport const INITIAL_FONT_PROPS: IFontMetrics = {\n  ascent: 10,\n  descent: 3,\n  fontSize: 13,\n};\n\n// TODO: Memoize\nexport const getFontPropertiesOfText = (\n  textField: PIXI.Text,\n  forceUpdate = false\n): IFontMetrics => {\n  if (forceUpdate) {\n    textField.updateText(false);\n    return measureFont(textField.context);\n  } else {\n    const props = measureFont(textField.context);\n    const fs = textField.style.fontSize ?? NaN;\n    if (\n      props.ascent === INITIAL_FONT_PROPS.ascent &&\n      props.descent === INITIAL_FONT_PROPS.descent &&\n      (isNaN(Number(fs)) || fs > INITIAL_FONT_PROPS.fontSize)\n    ) {\n      throw new Error(\n        \"getFontPropertiesOfText() returned metrics associated with a Text field that has not been updated yet. Please try using the forceUpdate parameter when you call this function.\"\n      );\n    }\n    return measureFont(textField.context);\n  }\n};\n\nexport const addChildrenToContainer = (\n  children: PIXI.DisplayObject[],\n  container: PIXI.Container\n): void => children.forEach((child) => container.addChild(child));\n\nexport const cloneSprite = (el: PIXI.Container): PIXI.Container => {\n  if ('clone' in el) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (el as any).clone();\n  }\n\n  return el instanceof PIXI.Sprite ? new PIXI.Sprite(el.texture) : el;\n};\n\nexport const fontSizeStringToNumber = (size: string): number => {\n  const [valueString, unit] = size.split(/(%|pt|px|r?em)/);\n  const value = parseFloat(valueString);\n\n  if (isNaN(value)) {\n    NaN;\n  }\n\n  switch (unit) {\n    case \"%\":\n      return value * PX_PER_PERCENT;\n    case \"em\":\n    case \"rem\":\n      return value * PX_PER_EM;\n    case \"pt\":\n      return value * PX_PER_PT;\n    case \"px\":\n    default:\n      // keep as is.\n      return value;\n  }\n};\n","import { convertUnsupportedAlignment, extractDecorations } from \"./style\";\nimport { capitalize, isOnlyWhitespace } from \"./stringUtil\";\nimport {\n  last,\n  first,\n  assoc,\n  mapProp,\n  flatReduce,\n  Unary,\n} from \"./functionalUtils\";\nimport { getFontPropertiesOfText } from \"./pixiUtils\";\nimport * as PIXI from \"pixi.js\";\nimport {\n  Align,\n  Bounds,\n  Point,\n  StyledTokens,\n  SegmentToken,\n  StyledToken,\n  TextToken,\n  SpriteToken,\n  SplitStyle,\n  TextStyleExtended,\n  IFontMetrics,\n  isNewlineToken,\n  isWhitespaceToken,\n  IMG_DISPLAY_PROPERTY,\n  isSpriteToken,\n  ParagraphToken,\n  LineToken,\n  WordToken,\n  Nested,\n  isNotWhitespaceToken,\n  VAlign,\n  createEmptySegmentToken,\n  FontMap,\n  ContainerToken,\n} from \"./types\";\n\nconst ICON_SCALE_BASE = 0.8;\n\nconst sizer = new PIXI.Text(\"\");\n\n/**\n * Translates the current location point to the beginning of the next line.\n *\n * @param offset An offset coordinate. The function will make a clone of this with new coordinates.\n * @param largestLineHeight The largest height in the line of text.\n * @param lineSpacing The amount of extra space to insert between each line.\n */\nexport const updateOffsetForNewLine = (\n  offset: Point,\n  largestLineHeight: number,\n  lineSpacing: number\n): Point => new PIXI.Point(0, offset.y + largestLineHeight + lineSpacing);\n\nconst rectFromContainer = (\n  container: PIXI.Container,\n  offset: Point = { x: 0, y: 0 }\n): Bounds => {\n  const w = container.width;\n  const h = container.height;\n  const x = offset.x + container.x;\n  const y = offset.y + container.y;\n\n  return new PIXI.Rectangle(x, y, w, h);\n};\n\n/**\n * Move a point by an offset.\n * Point p => p -> p-> -> p\n * @param offset Amount to translate the target.\n * @param point Target to translate.\n */\nexport const translatePoint =\n  <P extends Point>(offset: Point) =>\n  (point: P): P => ({\n    ...point,\n    x: point.x + offset.x,\n    y: point.y + offset.y,\n  });\n\n/**\n * Same as translatePoint but for all the points in an array.\n */\nexport const translateLine =\n  (offset: Point) =>\n  (line: Bounds[]): Bounds[] =>\n    line.map(translatePoint(offset));\n\nexport const translateWordPosition =\n  (offset: Point) =>\n  (word: WordToken): WordToken =>\n    word.map((token) =>\n      mapProp<Bounds, SegmentToken>(\"bounds\")(translatePoint(offset))(token)\n    );\n\nexport const translateTokenLine =\n  (offset: Point) =>\n  (line: LineToken): LineToken =>\n    line.map(translateWordPosition(offset));\n\nexport const lineWidth = (wordsInLine: Bounds[]): number => {\n  const firstWord = first(wordsInLine);\n  const lastWord = last(wordsInLine);\n\n  if (firstWord === undefined) {\n    return 0;\n  }\n  if (lastWord === firstWord) {\n    return firstWord.width;\n  }\n  return lastWord.x + lastWord.width - firstWord.x;\n};\n\nexport const center = (x: number, context: number): number => (context - x) / 2;\n\nconst setBoundsX = assoc<Bounds, number>(\"x\");\n\nconst positionWordX =\n  (x: number) =>\n  (word: WordToken): WordToken => {\n    let prevBounds: Bounds;\n    return word.map((token) => {\n      if (prevBounds === undefined) {\n        token.bounds.x = x;\n        prevBounds = token.bounds;\n      } else {\n        token.bounds.x = prevBounds.x + prevBounds.width;\n        prevBounds = token.bounds;\n      }\n      return token;\n    });\n  };\n\nexport const concatBounds = (\n  originalBounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN },\n  bounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN }\n): Bounds => {\n  if (isNaN(originalBounds.x)) {\n    return bounds;\n  }\n\n  const x = Math.min(originalBounds.x, bounds.x);\n  const y = Math.min(originalBounds.y, bounds.y);\n  const right = Math.max(\n    originalBounds.x + originalBounds.width,\n    bounds.x + bounds.width\n  );\n  const bottom = Math.max(\n    originalBounds.y + originalBounds.height,\n    bounds.y + bounds.height\n  );\n  const width = right - x;\n  const height = bottom - y;\n\n  return { x, y, width, height };\n};\n\nconst getCombinedBounds = (bounds: Bounds[]): Bounds =>\n  bounds.reduce(concatBounds, { x: NaN, y: NaN, width: NaN, height: NaN });\n\nexport const getBoundsNested: Unary<Nested<SegmentToken>, Bounds> = flatReduce<\n  SegmentToken,\n  Bounds\n>((acc: Bounds, t: SegmentToken) => concatBounds(acc, t.bounds), {\n  x: NaN,\n  y: NaN,\n  width: NaN,\n  height: NaN,\n});\n\ntype AlignFunction = (line: Bounds[]) => Bounds[];\ntype AlignFunctionMaxWidth = (maxWidth: number) => AlignFunction;\n\nexport const alignLeft: AlignFunction = (line) =>\n  line.reduce(\n    (newLine: Bounds[], bounds: Bounds, i: number): Bounds[] =>\n      // is first word?\n      i === 0\n        ? [setBoundsX(0)(bounds)]\n        : newLine.concat([\n            setBoundsX(newLine[i - 1].x + newLine[i - 1].width)(bounds),\n          ]),\n    []\n  );\n\nexport const alignRight: AlignFunctionMaxWidth = (maxWidth) => (line) =>\n  translateLine({\n    x: maxWidth - lineWidth(line),\n    y: 0,\n  })(alignLeft(line));\n\nexport const alignCenter: AlignFunctionMaxWidth = (maxWidth) => (line) =>\n  translateLine({ x: center(lineWidth(line), maxWidth), y: 0 })(\n    alignLeft(line)\n  );\n\nexport const alignJustify: AlignFunctionMaxWidth = (maxLineWidth) => (line) => {\n  const count = line.length;\n  if (count === 0) {\n    return [];\n  }\n\n  const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\n  const countNonZeroWidthWords = nonZeroWidthWords.length;\n\n  if (countNonZeroWidthWords === 1) {\n    const [first, ...rest] = line;\n    first.x = 0;\n    return [first, ...rest];\n  }\n\n  const result: Bounds[] = [];\n  const combinedBounds = getCombinedBounds(nonZeroWidthWords);\n  const w = combinedBounds.width;\n  const totalSpace = maxLineWidth - w;\n  const spacerWidth = totalSpace / (countNonZeroWidthWords - 1);\n\n  let previousWord;\n  for (let i = 0; i < line.length; i++) {\n    const bounds = line[i];\n    if (bounds.width === 0) {\n      result[i] = { ...bounds };\n      continue;\n    }\n    let x;\n    if (previousWord === undefined) {\n      x = 0;\n    } else {\n      x = previousWord.x + previousWord.width + spacerWidth;\n    }\n    if (isNaN(x)) {\n      throw new Error(\n        `Something went wrong with the justified layout calculation. x is NaN.`\n      );\n    }\n    const newWord: Bounds = setBoundsX(x)(bounds);\n    previousWord = newWord;\n    result[i] = newWord;\n  }\n  return result;\n};\n\nexport const alignLines = (\n  align: Align,\n  maxWidth: number,\n  lines: ParagraphToken\n): ParagraphToken => {\n  // do horizontal alignment.\n  let alignFunction: AlignFunction;\n  let lastAlignFunction: AlignFunction;\n  switch (align) {\n    case \"left\":\n      alignFunction = alignLeft;\n      lastAlignFunction = alignFunction;\n      break;\n    case \"right\":\n      alignFunction = alignRight(maxWidth);\n      lastAlignFunction = alignFunction;\n      break;\n    case \"center\":\n      alignFunction = alignCenter(maxWidth);\n      lastAlignFunction = alignFunction;\n      break;\n    case \"justify\":\n    case \"justify-left\":\n      alignFunction = alignJustify(maxWidth);\n      lastAlignFunction = alignLeft;\n      break;\n    case \"justify-right\":\n      alignFunction = alignJustify(maxWidth);\n      lastAlignFunction = alignRight(maxWidth);\n      break;\n    case \"justify-center\":\n      alignFunction = alignJustify(maxWidth);\n      lastAlignFunction = alignCenter(maxWidth);\n      break;\n    case \"justify-all\":\n      alignFunction = alignJustify(maxWidth);\n      lastAlignFunction = alignFunction;\n      break;\n    default:\n      throw new Error(\n        `Unsupported alignment type ${align}! Use one of : \"left\", \"right\", \"center\", \"justify\", \"justify-left\", \"justify-right\", justify-center\", \"justify-all\"`\n      );\n  }\n\n  for (const line of lines) {\n    const isLastLine =\n      // line is the last in the group OR\n      lines.indexOf(line) === lines.length - 1 ||\n      // line contains newline character\n      line.flat(2).filter(isNewlineToken).length > 0;\n\n    const wordBoundsForLine: Bounds[] = [];\n    let alignedLine;\n    for (const word of line) {\n      const wordBounds = getBoundsNested(word);\n      wordBoundsForLine.push(wordBounds);\n      if (isNaN(wordBounds.x)) {\n        throw new Error(\"wordBounds not correct\");\n      }\n    }\n    if (isLastLine) {\n      alignedLine = lastAlignFunction(wordBoundsForLine);\n    } else {\n      alignedLine = alignFunction(wordBoundsForLine);\n    }\n    for (let i = 0; i < line.length; i++) {\n      const bounds = alignedLine[i];\n      const word = line[i];\n      line[i] = positionWordX(bounds.x)(word);\n    }\n  }\n  return lines;\n};\n\nconst getTallestToken = (line: LineToken): SegmentToken =>\n  flatReduce<SegmentToken, SegmentToken>((tallest, current) => {\n    let h = current.bounds.height ?? 0;\n    if (isSpriteToken(current)) {\n      h += current.fontProperties.descent;\n    }\n    if (h > (tallest?.bounds.height ?? 0)) {\n      return current;\n    }\n    return tallest;\n  }, createEmptySegmentToken())(line);\n\nexport const verticalAlignInLines = (\n  lines: ParagraphToken,\n  lineSpacing: number,\n  overrideValign?: VAlign // If you want to override the valign from the styles object, set it here.\n): ParagraphToken => {\n  let previousTallestToken: SegmentToken = createEmptySegmentToken();\n  let previousLineBottom = 0;\n  let paragraphModifier = 0;\n\n  const newLines: ParagraphToken = [];\n\n  for (const line of lines) {\n    const newLine: LineToken = [];\n\n    let tallestToken: SegmentToken = getTallestToken(line);\n    // Note, paragraphModifier from previous line applied here.\n    let tallestHeight = (tallestToken.bounds?.height ?? 0) + paragraphModifier;\n    let tallestAscent =\n      (tallestToken.fontProperties?.ascent ?? 0) + paragraphModifier;\n    const valignParagraphModifier = paragraphModifier;\n    paragraphModifier = 0;\n\n    const lastToken = line[line.length - 1][0];\n    if (isNewlineToken(lastToken)) {\n      // Note, this will get applied on the NEXT line\n      paragraphModifier = tallestToken.style.paragraphSpacing ?? 0;\n    }\n    if (isSpriteToken(tallestToken)) {\n      tallestHeight += tallestToken.fontProperties.descent;\n      tallestAscent = tallestToken.bounds.height;\n    }\n\n    if (tallestHeight === 0) {\n      tallestToken = previousTallestToken;\n    } else {\n      previousTallestToken = tallestToken;\n    }\n\n    for (const word of line) {\n      const newWord: WordToken = [];\n      for (const segment of word) {\n        const { bounds, fontProperties, style } = segment;\n        const { height } = bounds;\n\n        const newBounds: Bounds = { ...bounds };\n        const valign = overrideValign ?? style.valign;\n\n        let { ascent } = fontProperties;\n        if (isSpriteToken(segment)) {\n          ascent = segment.bounds.height;\n        }\n\n        if (isNewlineToken(segment)) {\n          const newToken = {\n            ...segment,\n          };\n          newToken.bounds.y = previousLineBottom + tallestAscent - ascent;\n          newWord.push(newToken);\n          continue;\n        }\n\n        // Every valignment starts at the previous line bottom.\n        let newY = previousLineBottom;\n        switch (valign) {\n          case \"bottom\":\n            newY += tallestHeight - height;\n            break;\n          case \"middle\":\n            // Need to account for how paragraph spacing affects the middle positioning.\n            newY += (tallestHeight + valignParagraphModifier - height) / 2;\n            break;\n          case \"top\":\n            // Normally the change would be 0px but we need to account for paragraph spacing.\n            newY += valignParagraphModifier;\n            break;\n          case \"baseline\":\n          default:\n            newY += tallestAscent - ascent;\n        }\n        newBounds.y = newY;\n\n        const newToken = {\n          ...segment,\n          bounds: newBounds,\n        };\n        newWord.push(newToken);\n      }\n      newLine.push(newWord);\n    }\n\n    previousLineBottom += tallestHeight + lineSpacing;\n    newLines.push(newLine);\n  }\n\n  return newLines;\n};\n\nexport const collapseWhitespacesOnEndOfLines = (\n  lines: ParagraphToken\n): ParagraphToken => {\n  for (const line of lines) {\n    const l = line.length;\n    let i = l;\n    while (i >= 0) {\n      i -= 1;\n      const word = line[i];\n      if (isNotWhitespaceToken(word)) {\n        break;\n      } else {\n        for (const token of word) {\n          token.bounds.width = 0;\n          token.bounds.height = Math.min(\n            token.bounds.height,\n            token.fontProperties.fontSize\n          );\n        }\n      }\n    }\n  }\n  return lines;\n};\n\nconst layout = (\n  tokens: SegmentToken[],\n  maxWidth: number,\n  lineSpacing: number,\n  align: Align,\n  splitStyle: SplitStyle\n): ParagraphToken => {\n  const cursor = { x: 0, y: 0 };\n  let wordWidth = 0;\n  let word: WordToken = [];\n  let line: LineToken = [];\n  const allLines: ParagraphToken = [];\n  let tallestHeightInLine = 0;\n  let token: SegmentToken;\n\n  for (let i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n    // when using an unbroken line (breakLines === false), treat the entire line as one word\n    // unless you encounter one that isn't unbroken or a newline character\n    const normalLineBreaks = hasNormalLineBreaks(token);\n    const isWhitespace = isWhitespaceToken(token);\n    const isNewline = isNewlineToken(token);\n    const isImage = isSpriteToken(token);\n    const isWordEndingToken = isWhitespace || isImage;\n\n    if (\n      (isWordEndingToken && normalLineBreaks) ||\n      isNewline ||\n      token.style.breakWords\n    ) {\n      positionWordBufferAndAddToLine();\n    }\n\n    addTokenToWordAndUpdateWordWidth(token);\n    setTallestHeight(token);\n\n    // always immediately add whitespace to the line.\n    if ((isWhitespace && normalLineBreaks) || isNewline) {\n      positionWordBufferAndAddToLine();\n    }\n\n    // If the token is a newline character,\n    // move the cursor to next line immediately\n    if (isNewline || isBlockImage(token)) {\n      addLineToListOfLinesAndMoveCursorToNextLine(token);\n    } else if (wordInBufferExceedsLineLength()) {\n      // don't wrap if it's the first word in the line.\n      if (line.length > 0) {\n        addLineToListOfLinesAndMoveCursorToNextLine(token);\n      }\n    }\n  }\n\n  // After we reach the last token, add it to the word and finalize both buffers.\n  if (word.length > 0) {\n    positionWordBufferAndAddToLine();\n  }\n  if (line.length > 0) {\n    addLineToListOfLines();\n  }\n\n  const collapsedWhitespace = collapseWhitespacesOnEndOfLines(allLines);\n  const alignedLines = alignLines(align, maxWidth, collapsedWhitespace);\n  const valignedLines = verticalAlignInLines(alignedLines, lineSpacing);\n\n  return valignedLines;\n\n  function addWordBufferToLineBuffer() {\n    if (word !== undefined && word.length > 0) {\n      // add word to line\n      line.push(word);\n    }\n\n    // reset word buffer\n    word = [];\n    wordWidth = 0;\n  }\n\n  function addLineToListOfLines() {\n    allLines.push(line);\n    line = [];\n  }\n\n  function addLineToListOfLinesAndMoveCursorToNextLine(token: SegmentToken) {\n    // finalize Line\n    addLineToListOfLines();\n\n    // move cursor to next line\n    cursor.x = 0;\n    cursor.y = cursor.y + tallestHeightInLine;\n\n    // reset tallestHeight\n    tallestHeightInLine = 0;\n    setTallestHeight(token);\n  }\n\n  function setTallestHeight(token?: SegmentToken): void {\n    const fontSize = token?.fontProperties?.fontSize ?? 0;\n    const height = token?.bounds?.height ?? 0;\n\n    tallestHeightInLine = Math.max(tallestHeightInLine, fontSize, lineSpacing);\n\n    // Don't try to measure the height of newline tokens\n    if (isNewlineToken(token) === false) {\n      tallestHeightInLine = Math.max(tallestHeightInLine, height);\n    }\n  }\n\n  function positionTokenAtCursorAndAdvanceCursor(token: SegmentToken): void {\n    // position token at cursor\n    setTallestHeight(token);\n    token.bounds.x = cursor.x;\n    token.bounds.y = cursor.y;\n    // advance cursor\n    cursor.x += token.bounds.width;\n  }\n\n  function positionWordBufferAtCursorAndAdvanceCursor(): void {\n    word.forEach(positionTokenAtCursorAndAdvanceCursor);\n  }\n\n  function wordInBufferExceedsLineLength(): boolean {\n    return cursor.x + wordWidth > maxWidth;\n  }\n\n  function isBlockImage(token: SegmentToken): boolean {\n    return token.style[IMG_DISPLAY_PROPERTY] === \"block\";\n  }\n\n  function hasNormalLineBreaks(token: SegmentToken): boolean {\n    return token.style.breakLines ?? true;\n  }\n\n  function addTokenToWordAndUpdateWordWidth(token: SegmentToken): void {\n    // add the token to the current word buffer.\n    word.push(token);\n    wordWidth += token.bounds.width;\n  }\n\n  function positionWordBufferAndAddToLine() {\n    positionWordBufferAtCursorAndAdvanceCursor();\n    addWordBufferToLineBuffer();\n  }\n};\n\nconst notEmptyString = (s: string) => s !== \"\";\n\nconst SPLIT_MARKER = `_🔪_`;\nexport const splitAroundWhitespace = (s: string): string[] =>\n  s\n    .replace(/\\s/g, `${SPLIT_MARKER}$&${SPLIT_MARKER}`)\n    .split(SPLIT_MARKER)\n    .filter((s) => s !== \"\");\n\nexport const splitText = (s: string, splitStyle: SplitStyle): string[] => {\n  if (splitStyle === \"words\") {\n    return [s].flatMap(splitAroundWhitespace).filter(notEmptyString);\n  } else if (splitStyle === \"characters\") {\n    return s.split(\"\");\n  } else {\n    // unsupported splitStyle.\n    let suggestion = ` Supported styles are \"words\" and \"characters\"`;\n    const badStyle = (splitStyle as string).toLowerCase();\n    if (badStyle.indexOf(\"char\") === 0) {\n      suggestion = `Did you mean \"characters\"?`;\n    } else if (badStyle.indexOf(\"wor\") === 0) {\n      suggestion = `Did you mean \"words\"?`;\n    }\n    throw new Error(`Unsupported split style \"${splitStyle}\". ${suggestion}`);\n  }\n};\n\nexport const calculateTokens = (\n  styledTokens: StyledTokens,\n  splitStyle: SplitStyle = \"words\",\n  scaleIcons = true,\n  adjustFontBaseline?: FontMap\n): ParagraphToken => {\n  // Create a text field to use for measurements.\n  const defaultStyle = styledTokens.style;\n\n  let fontProperties: IFontMetrics;\n\n  const generateTokensFormStyledToken =\n    (style: TextStyleExtended, tags: string) =>\n    (token: StyledToken | TextToken | SpriteToken | ContainerToken): SegmentToken[] => {\n      let output: SegmentToken[] = [];\n\n      const alignClassic = convertUnsupportedAlignment(style.align);\n\n      sizer.style = {\n        ...style,\n        align: alignClassic,\n        // Override some styles for the purposes of sizing text.\n        wordWrap: false,\n        dropShadowBlur: 0,\n        dropShadowDistance: 0,\n        dropShadowAngle: 0,\n        dropShadow: false,\n      };\n\n      if (typeof token === \"string\") {\n        // split into pieces and convert into tokens.\n\n        const textSegments = splitText(token, splitStyle);\n\n        const textTokens = textSegments.map((str): SegmentToken => {\n          switch (style.textTransform) {\n            case \"uppercase\":\n              sizer.text = str.toUpperCase();\n              break;\n            case \"lowercase\":\n              sizer.text = str.toLowerCase();\n              break;\n            case \"capitalize\":\n              sizer.text = capitalize(str);\n              break;\n            default:\n              sizer.text = str;\n          }\n\n          fontProperties = { ...getFontPropertiesOfText(sizer, true) };\n\n          // Incorporate the size of the stroke into the size of the text.\n          if (isOnlyWhitespace(token) === false) {\n            const stroke = sizer.style.strokeThickness ?? 0;\n            if (stroke > 0) {\n              fontProperties.descent += stroke / 2;\n              fontProperties.ascent += stroke / 2;\n              fontProperties.fontSize =\n                fontProperties.ascent + fontProperties.descent;\n            }\n          }\n\n          const sw = style.fontScaleWidth ?? 1.0;\n          const sh = style.fontScaleHeight ?? 1.0;\n          // clamp negative or NaN fontScales to 0\n          const scaleWidth = isNaN(sw) || sw < 0 ? 0.0 : sw;\n          const scaleHeight = isNaN(sh) || sh < 0 ? 0.0 : sh;\n\n          sizer.scale.set(scaleWidth, scaleHeight);\n\n          fontProperties.ascent *= scaleHeight;\n          fontProperties.descent *= scaleHeight;\n          fontProperties.fontSize *= scaleHeight;\n\n          const bounds = rectFromContainer(sizer);\n          // bounds.height = fontProperties.fontSize;\n\n          const textDecorations = extractDecorations(\n            style,\n            bounds,\n            fontProperties\n          );\n\n          const baselineAdjustment = getBaselineAdjustment(\n            style,\n            adjustFontBaseline,\n            fontProperties.ascent\n          );\n          fontProperties.ascent += baselineAdjustment;\n\n          const { letterSpacing } = style;\n          if (letterSpacing) {\n            bounds.width += letterSpacing;\n          }\n\n          const convertedToken = {\n            content: str,\n            style,\n            tags,\n            bounds,\n            fontProperties,\n            textDecorations,\n          };\n\n          // Required to remove extra stroke width from whitespace.\n          // to be totally honest, I'm not sure why this works / why it was being added.\n          if (isOnlyWhitespace(str)) {\n            bounds.width -= style.strokeThickness ?? 0;\n          }\n          return convertedToken;\n        });\n\n        output = output.concat(textTokens);\n      } else if (token instanceof PIXI.Container) {\n        const sprite = token;\n        const imgDisplay = style[IMG_DISPLAY_PROPERTY];\n        // const isBlockImage = imgDisplay === \"block\";\n        const isIcon = imgDisplay === \"icon\";\n        fontProperties = { ...getFontPropertiesOfText(sizer, true) };\n\n        if (isIcon) {\n          const rect = new PIXI.Container();\n          rect.addChild(sprite);\n\n          // Set to minimum of 1 to avoid devide by zero.\n          // if it's height is zero or one it probably hasn't loaded yet.\n          // It will get refreshed after it loads.\n          const h = Math.max(rect.height, 1);\n\n          if (h > 1 && sprite.scale.y === 1) {\n            const { iconScale = 1.0 } = style;\n            const ratio =\n              (fontProperties.ascent / h) * ICON_SCALE_BASE * iconScale;\n            sprite.scale.set(ratio);\n          }\n\n          if (scaleIcons) {\n            const {\n              fontScaleWidth: scaleX = 1.0,\n              fontScaleHeight: scaleY = 1.0,\n            } = style;\n            sprite.scale.x *= scaleX;\n            sprite.scale.y *= scaleY;\n          }\n        }\n\n        // handle images\n        const bounds = new PIXI.Container();\n        bounds.addChild(sprite);\n\n        const { letterSpacing } = style;\n        if (letterSpacing && isIcon) {\n          bounds.width += letterSpacing;\n        }\n\n        output.push({\n          content: sprite,\n          style,\n          tags,\n          bounds,\n          fontProperties,\n          textDecorations: undefined,\n        });\n      } else {\n        // token is a composite\n        const styledToken = token as StyledToken;\n        const { children } = styledToken;\n        // set tags and styles for children of this composite token.\n        const newStyle = styledToken.style;\n        const newTags = styledToken.tags;\n\n        if (newStyle === undefined) {\n          throw new Error(\n            `Expected to find a 'style' property on ${styledToken}`\n          );\n        }\n\n        output = output.concat(\n          children.flatMap(generateTokensFormStyledToken(newStyle, newTags))\n        );\n      }\n      return output;\n    };\n\n  // when starting out, use the default style\n  const tags = \"\";\n  const style: TextStyleExtended = defaultStyle;\n\n  const finalTokens = styledTokens.children.flatMap(\n    generateTokensFormStyledToken(style, tags)\n  );\n\n  const { wordWrap: ww, wordWrapWidth: www } = defaultStyle;\n  const hasWordWrapWidth = www !== undefined && isNaN(www) === false && www > 0;\n  const maxWidth =\n    ww && hasWordWrapWidth ? (www as number) : Number.POSITIVE_INFINITY;\n\n  const lineSpacing = defaultStyle.lineSpacing ?? 0;\n  const align = defaultStyle.align ?? \"left\";\n\n  const lines = layout(finalTokens, maxWidth, lineSpacing, align, splitStyle);\n\n  return lines;\n};\n\nexport const getBaselineAdjustment = (\n  style: TextStyleExtended,\n  fontBaselineMap: FontMap = {},\n  ascent: number\n): number => {\n  const fontFamily = style.fontFamily?.toString() ?? \"\";\n  const adjustBaseline = style.adjustBaseline ?? 0;\n  const adjustFontBaseline = fontBaselineMap[fontFamily] ?? null;\n\n  let finalValue = adjustBaseline;\n  if (typeof adjustFontBaseline === \"string\") {\n    const percentPair = adjustFontBaseline.split(\"%\");\n    const isPercent = percentPair.length > 1;\n    const value = Number(percentPair[0]);\n\n    if (isPercent) {\n      finalValue += ascent * (value / 100);\n    } else {\n      finalValue += value;\n    }\n  } else {\n    finalValue += Number(adjustFontBaseline);\n  }\n  return finalValue;\n};\n","import { TaggedTextOptions } from \"./types\";\n\nconst DEFAULT_OPTIONS: TaggedTextOptions = {\n  debug: false,\n  debugConsole: false,\n  splitStyle: \"words\",\n  imgMap: {},\n  scaleIcons: true,\n  skipUpdates: false,\n  skipDraw: false,\n  drawWhitespace: false,\n  wrapEmoji: true,\n  errorHandler: undefined,\n  supressConsole: false,\n  overdrawDecorations: 0,\n};\n\nexport default DEFAULT_OPTIONS;\n","import * as PIXI from \"pixi.js\";\nimport {\n  TaggedTextOptions,\n  TextStyleSet,\n  TextStyleExtended,\n  TagWithAttributes,\n  AttributesList,\n  ImageMap,\n  ImageSourceMap,\n  IMG_REFERENCE_PROPERTY,\n  SegmentToken,\n  isSpriteToken,\n  TextSegmentToken,\n  isTextToken,\n  isNotWhitespaceToken,\n  isNewlineToken,\n  isWhitespaceToken,\n  Point,\n  ParagraphToken,\n  TextDecorationMetrics,\n  isSpriteSource,\n  isTextureSource,\n  DEFAULT_KEY,\n} from \"./types\";\n\nimport { parseTagsNew, removeTags, EMOJI_TAG } from \"./tags\";\nimport {\n  combineAllStyles,\n  convertUnsupportedAlignment,\n  getStyleForTag as getStyleForTagExt,\n  mapTagsToStyles,\n} from \"./style\";\nimport { calculateTokens, getBoundsNested } from \"./layout\";\nimport { capitalize } from \"./stringUtil\";\nimport { fontSizeStringToNumber } from \"./pixiUtils\";\nimport { logWarning as _logWarning } from \"./errorMessaging\";\n\nimport DEFAULT_STYLE from \"./defaultStyle\";\nimport DEFAULT_OPTIONS from \"./defaultOptions\";\n\n// TODO: make customizable\nconst DEBUG = {\n  WORD_STROKE_COLOR: 0xffcccc,\n  WORD_FILL_COLOR: 0xeeeeee,\n  TEXT_FIELD_STROKE_COLOR: 0xff00ff,\n  WHITESPACE_COLOR: 0xcccccc,\n  WHITESPACE_STROKE_COLOR: 0xaaaaaa,\n  BASELINE_COLOR: 0xffff99,\n  LINE_COLOR: 0xffff00,\n  OUTLINE_COLOR: 0xffcccc,\n  OUTLINE_SHADOW_COLOR: 0x000000,\n  TEXT_STYLE: {\n    fontFamily: \"courier\",\n    fontSize: 10,\n    fill: 0xffffff,\n    dropShadow: true,\n  },\n};\n\ntype PixiTextType = PIXI.BitmapText | PIXI.Text;\n\nconst DEFAULT_STYLE_SET = { default: DEFAULT_STYLE };\nObject.freeze(DEFAULT_STYLE_SET);\nObject.freeze(DEFAULT_STYLE);\n\nconst DEFAULT_DESTROY_OPTIONS: PIXI.IDestroyOptions = {\n  children: true,\n  texture: true,\n};\n\n/**\n * Returns a hash code for an object.\n *\n * @see https://stackoverflow.com/a/8831937\n */\nfunction _hashCode(value: object): number {\n  const str = JSON.stringify(value, Object.keys(value).sort());\n\n  let hash = 0;\n  for (let i = 0, len = str.length; i < len; i++) {\n      const chr = str.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\n/**\n * 'always' - Always uses `PIXI.BitmapText`. Generates missing `PIXI.BitmapFont`.\n * 'prefer' - Prefers `PIXI.BitmapText` if a `PIXI.BitmapFont` is loaded. Otherwise uses `PIXI.Text`.\n * 'disabled' - Always uses `PIXI.Text`.\n *\n * @see {TaggedText.DEFAULT_BITMAP_TEXT_BEHAVIOR}\n */\ntype BitmapTextBehavior = 'always' | 'prefer' | 'disabled';\n\nexport default class TaggedText extends PIXI.Sprite {\n  public static get defaultStyles(): TextStyleSet {\n    return DEFAULT_STYLE_SET;\n  }\n  public static get defaultOptions(): TaggedTextOptions {\n    return DEFAULT_OPTIONS;\n  }\n\n  /**\n   * Configurable IBitmapFontOptions\n   */\n  public static DEFAULT_BITMAP_FONT_OPTIONS: PIXI.IBitmapFontOptions = {\n    chars: PIXI.BitmapFont.ASCII, // Generate font glyphs for ASCII characters.\n    resolution: window.devicePixelRatio, // Use HiDPI fonts on HiDPI devices.\n  };\n\n  /**\n   * Behavior for generating bitmap text.\n   */\n  public static DEFAULT_BITMAP_TEXT_BEHAVIOR: BitmapTextBehavior = 'always';\n\n  /** Bitmap font behavior for generated fonts. */\n  private _bitmapFontOptions: PIXI.IBitmapFontOptions;\n  /** Bitmap font behavior for generating fonts. */\n  private _bitmapTextBehavior: BitmapTextBehavior;\n\n  /** Settings for the TaggedText component. */\n  private _options: TaggedTextOptions;\n  public get options(): TaggedTextOptions {\n    return this._options;\n  }\n\n  private _needsUpdate = true;\n  public get needsUpdate(): boolean {\n    return this._needsUpdate;\n  }\n  private _needsDraw = true;\n  public get needsDraw(): boolean {\n    return this._needsDraw;\n  }\n\n  private _tokens: ParagraphToken = [];\n  /**\n   * Tokens representing parsed out and styled tagged text. This is generated by update.\n   * They contain all the information needed to render the text fields and other children in your component.\n   */\n  public get tokens(): ParagraphToken {\n    return this._tokens;\n  }\n  public get tokensFlat(): SegmentToken[] {\n    return this._tokens.flat(3);\n  }\n\n  private _text = \"\";\n  public get text(): string {\n    return this._text;\n  }\n\n  /**\n   * Alternative implicit setter for text. Always uses default for skipUpdate.\n   */\n  public set text(text: string) {\n    this.setText(text);\n  }\n\n  /**\n   * Setter for text that allows you to override the default for skipping the update.\n   * @param text Text to add to component with (optional) tags.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the text.\n   * When true, setText() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setText(text: string, skipUpdate?: boolean): void {\n    if (text === this._text && this._needsUpdate === false) {\n      return;\n    }\n    this._text = text;\n    this._needsUpdate = true;\n    this.updateIfShould(skipUpdate);\n  }\n\n  /**\n   * Returns the text content with all tags stripped out.\n   */\n  public get untaggedText(): string {\n    return removeTags(this.text);\n  }\n\n  private _tagStyles: TextStyleSet = {};\n  public get tagStyles(): TextStyleSet {\n    return this._tagStyles;\n  }\n\n  /**\n   * Alternative implicit setter for tagStyles. Always uses default for skipUpdate.\n   */\n  public set tagStyles(styles: TextStyleSet) {\n    this.setTagStyles(styles);\n  }\n\n  /**\n   * Setter for tagStyles.\n   * @param styles Object with strings for keys representing tag names, mapped to style objects.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, setTagStyles() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setTagStyles(styles: TextStyleSet, skipUpdate?: boolean): void {\n    Object.entries(styles).forEach(([tag, style]) =>\n      this.setStyleForTag(tag, style, true)\n    );\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\n    this._needsUpdate = true;\n    this.updateIfShould(skipUpdate);\n  }\n\n  public getStyleForTag(\n    tag: string,\n    attributes: AttributesList = {}\n  ): TextStyleExtended | undefined {\n    return getStyleForTagExt(tag, this.tagStyles, attributes);\n  }\n\n  public getStyleForTags(tags: TagWithAttributes[]): TextStyleExtended {\n    const styles = tags.map(({ tagName, attributes }) =>\n      this.getStyleForTag(tagName, attributes)\n    );\n    return combineAllStyles(styles);\n  }\n\n  /**\n   * Set a style to be used by a single tag.\n   * @param tag Name of the tag to set style for\n   * @param styles Style object to assign to the tag.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, setStyleForTag() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setStyleForTag(\n    tag: string,\n    styles: TextStyleExtended,\n    skipUpdate?: boolean\n  ): boolean {\n    this.tagStyles[tag] = styles;\n\n    // TODO: warn user when trying to set styles on a tag that doesn't support it...\n    // e.g. wordWrapWidth on a styel other than default.\n\n    // Override some settings on default styles.\n    if (tag === DEFAULT_KEY && this.defaultStyle[IMG_REFERENCE_PROPERTY]) {\n      // prevents accidentally setting all text to images.\n      this.logWarning(\n        `${IMG_REFERENCE_PROPERTY}-on-default`,\n        `Style \"${IMG_REFERENCE_PROPERTY}\" can not be set on the \"${DEFAULT_KEY}\" style because it will add images to EVERY tag!`\n      );\n      this.defaultStyle[IMG_REFERENCE_PROPERTY] = undefined;\n    }\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\n    this._needsUpdate = true;\n    this.updateIfShould(skipUpdate);\n\n    return true;\n  }\n  /**\n   * Removes a style associated with a tag. Note, inline attributes are not affected.\n   * @param tag Name of the tag to delete the style of.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, removeStylesForTag() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public removeStylesForTag(tag: string, skipUpdate?: boolean): boolean {\n    if (tag in this.tagStyles) {\n      delete this.tagStyles[tag];\n\n      this._needsUpdate = true;\n      this.updateIfShould(skipUpdate);\n\n      return true;\n    }\n    return false;\n  }\n\n  public get defaultStyle(): TextStyleExtended {\n    return this.tagStyles?.default;\n  }\n  /**\n   * Alternative implicit setter for defaultStyle. Always uses default for skipUpdate.\n   */\n  public set defaultStyle(defaultStyles: TextStyleExtended) {\n    this.setDefaultStyle(defaultStyles);\n  }\n  /**\n   * Setter for default styles. A shortcut to this.setStyleForTag(\"default\",...)\n   * @param styles A style object to use as the default styles for all text in the component.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, setDefaultStyle() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setDefaultStyle(\n    defaultStyles: TextStyleExtended,\n    skipUpdate?: boolean\n  ): void {\n    this.setStyleForTag(DEFAULT_KEY, defaultStyles, skipUpdate);\n  }\n\n  // References to internal elements.\n  private _textFields: PixiTextType[] = [];\n  public get textFields(): PixiTextType[] {\n    return this._textFields;\n  }\n  private _sprites: PIXI.Sprite[] = [];\n  public get sprites(): PIXI.Sprite[] {\n    return this._sprites;\n  }\n  private _decorations: PIXI.Graphics[] = [];\n  public get decorations(): PIXI.Graphics[] {\n    return this._decorations;\n  }\n  private _spriteTemplates: ImageMap = {};\n  public get spriteTemplates(): ImageMap {\n    return this._spriteTemplates;\n  }\n  private _debugGraphics: PIXI.Graphics;\n\n  // Containers for children\n  private _textContainer: PIXI.Container;\n  public get textContainer(): PIXI.Container {\n    return this._textContainer;\n  }\n\n  private _decorationContainer: PIXI.Container;\n  public get decorationContainer(): PIXI.Container {\n    return this._decorationContainer;\n  }\n\n  private _spriteContainer: PIXI.Container;\n  public get spriteContainer(): PIXI.Container {\n    return this._spriteContainer;\n  }\n  private _debugContainer: PIXI.Container;\n  public get debugContainer(): PIXI.Container {\n    return this._debugContainer;\n  }\n\n  private logWarning = (code: string, message: string): void =>\n    _logWarning(\n      this.options.errorHandler,\n      this.options.supressConsole,\n      this\n    )(code, message);\n\n  constructor(\n    text = \"\",\n    tagStyles: TextStyleSet = {},\n    options: TaggedTextOptions = {},\n    bitmapFontOptions?: PIXI.IBitmapFontOptions,\n    bitmapTextBehavior?: BitmapTextBehavior,\n    texture?: PIXI.Texture,\n  ) {\n    super(texture);\n\n    this._textContainer = new PIXI.Container();\n    this._spriteContainer = new PIXI.Container();\n    this._decorationContainer = new PIXI.Container();\n    this._debugContainer = new PIXI.Container();\n    this._debugGraphics = new PIXI.Graphics();\n\n    this._bitmapFontOptions = bitmapFontOptions ?? TaggedText.DEFAULT_BITMAP_FONT_OPTIONS;\n    this._bitmapTextBehavior = bitmapTextBehavior ?? TaggedText.DEFAULT_BITMAP_TEXT_BEHAVIOR;\n\n    this.resetChildren();\n\n    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n    this._options = mergedOptions;\n\n    tagStyles = { default: {}, ...tagStyles };\n\n    if (this.options.wrapEmoji) {\n      const userStyles = tagStyles[EMOJI_TAG];\n      tagStyles[EMOJI_TAG] = {\n        fontFamily: \"sans-serif\",\n        ...userStyles,\n      };\n    }\n    const mergedDefaultStyles = { ...DEFAULT_STYLE, ...tagStyles.default };\n    tagStyles.default = mergedDefaultStyles;\n    this.tagStyles = tagStyles;\n\n    if (this.options.imgMap) {\n      this.createSpriteTemplatesFromSourceMap(this.options.imgMap);\n    }\n\n    this.text = text;\n  }\n\n  public destroyImgMap(): void {\n    if (this.destroyed) {\n      throw new Error(\n        \"destroyImgMap() was called after this object was already destroyed. You must call destroyImgMap() before destroy() because imgMap is cleared when the object is destroyed.\"\n      );\n    }\n\n    this._spriteContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true,\n    });\n  }\n\n  public destroy(options?: boolean | PIXI.IDestroyOptions): void {\n    let destroyOptions: PIXI.IDestroyOptions = {};\n    if (typeof options === \"boolean\") {\n      options = { children: options };\n    }\n    destroyOptions = { ...DEFAULT_DESTROY_OPTIONS, ...options };\n\n    // Do not destroy the sprites in the imgMap.\n    this._spriteContainer.destroy(false);\n\n    super.destroy(destroyOptions);\n\n    this._textFields = [];\n    this._sprites = [];\n    this._decorations = [];\n    this._spriteTemplates = {};\n    this._tokens = [];\n    this._tagStyles = {};\n    this._options.imgMap = {};\n    this._options.skipUpdates = true;\n    this._options.skipDraw = true;\n    this._options = {};\n  }\n\n  /**\n   * Removes all PIXI children from this component's containers.\n   * Deletes references to sprites and text fields.\n   */\n  private resetChildren() {\n    if (this._textContainer) {\n      this._textContainer.removeChildren();\n      this.removeChild(this._textContainer);\n    }\n    this._textContainer = new PIXI.Container();\n    this.addChild(this._textContainer);\n\n    if (this._spriteContainer) {\n      this._spriteContainer.removeChildren();\n      this.removeChild(this._spriteContainer);\n    }\n    this._spriteContainer = new PIXI.Container();\n    this.addChild(this._spriteContainer);\n\n    if (this._decorationContainer) {\n      this._decorationContainer.removeChildren();\n      this.removeChild(this._decorationContainer);\n    }\n    this._decorationContainer = new PIXI.Container();\n    this.addChild(this._decorationContainer);\n\n    if (this._debugContainer) {\n      this._debugContainer.removeChildren();\n      this.removeChild(this._debugContainer);\n    }\n    this._debugContainer = new PIXI.Container();\n    this.addChild(this._debugContainer);\n\n    this._textFields = [];\n    this._sprites = [];\n    this._decorations = [];\n  }\n\n  /**\n   * Creates associations between string-based keys like \"img\" and\n   * image Sprite objects which are included in the text.\n   * @param imgMap\n   */\n  private createSpriteTemplatesFromSourceMap(imgMap: ImageSourceMap) {\n    this._spriteTemplates = {};\n\n    Object.entries(imgMap).forEach(([key, spriteSource]) => {\n      const wrongFormatError = new TypeError(\n        `The spriteSource provided for key ${key} was not in a valid format. Please use a Sprite, Texture, BaseTexture, string, HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, or SVGElement`\n      );\n      const destroyedError = new Error(\n        `The spriteSource provided for key ${key} appears to be a Sprite or Texture that has been destroyed or removed from PIXI.TextureCache probably using \\`destroy()\\` with aggressive options or \\`destroyImgMap()\\`.`\n      );\n      let error: Error | null = null;\n\n      let sprite: PIXI.Container = new PIXI.Sprite();\n\n      try {\n        if (spriteSource instanceof PIXI.Container) {\n          sprite = spriteSource;\n        }\n        // if the entry is not a sprite, attempt to load the sprite as if it is a reference to the sprite source (e.g. an Image element, url, or texture).\n        else if (isSpriteSource(spriteSource)) {\n          sprite = PIXI.Sprite.from(spriteSource);\n        } else if (isTextureSource(spriteSource)) {\n          sprite = PIXI.Sprite.from(PIXI.Texture.from(spriteSource));\n        } else {\n          error = wrongFormatError;\n          console.log(error);\n        }\n      } catch (e) {\n        error = e as Error;\n        console.log(error);\n      }\n\n      if (\n        (isSpriteSource(spriteSource) &&\n          (spriteSource as PIXI.Texture).baseTexture === null) ||\n        (sprite !== undefined &&\n          (sprite.destroyed || (sprite instanceof PIXI.Sprite && sprite.texture?.baseTexture === null)))\n      ) {\n        error = destroyedError;\n        console.log(error);\n      }\n\n      if (error) {\n        throw error;\n      }\n\n      if (sprite instanceof PIXI.Sprite) {\n        // Listen for changes to sprites (e.g. when they load.)\n        const texture = sprite.texture;\n\n        const onTextureUpdate = (baseTexture: PIXI.BaseTexture) => {\n          this.onImageTextureUpdate(baseTexture);\n          baseTexture.removeListener(\"update\", onTextureUpdate);\n        };\n\n        texture.baseTexture.addListener(\"update\", onTextureUpdate);\n      }\n\n      this.spriteTemplates[key] = sprite;\n\n      // create a style for each of these by default.\n      const existingStyle = this.getStyleForTag(key) ?? {};\n      const style = { [IMG_REFERENCE_PROPERTY]: key, ...existingStyle };\n      this.setStyleForTag(key, style);\n    });\n  }\n\n  private onImageTextureUpdate(baseTexture: PIXI.BaseTexture): void {\n    baseTexture;\n    this._needsUpdate = true;\n    this._needsDraw = true;\n    this.updateIfShould();\n  }\n\n  /**\n   * Determines whether to call update based on the parameter and the options set then calls it or sets needsUpdate to true.\n   * @param forcedSkipUpdate This is the parameter provided to some functions that allow you to skip the update.\n   * It's factored in along with the defaults to figure out what to do.\n   */\n  private updateIfShould(forcedSkipUpdate?: boolean): boolean {\n    if (\n      forcedSkipUpdate === false ||\n      (forcedSkipUpdate === undefined && this.options.skipUpdates === false)\n    ) {\n      this.update();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Calculates styles, positioning, etc. of the text and styles and creates a\n   * set of objects that represent where each portion of text and image should\n   * be drawn.\n   * @param skipDraw *For advanced users* overrides default for redrawing the styles.\n   * When true, update() will skip the call to draw() (even if the default is false).\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public update(skipDraw?: boolean): ParagraphToken {\n    // Determine default style properties\n    const tagStyles = this.tagStyles;\n    const { splitStyle, scaleIcons } = this.options;\n    const spriteTemplates = this.options.imgMap && this.spriteTemplates;\n    // const wordWrapWidth = this.defaultStyle.wordWrap\n    //   ? this.defaultStyle.wordWrapWidth\n    //   : Number.POSITIVE_INFINITY;\n    // const align = this.defaultStyle.align;\n    // const lineSpacing = this.defaultStyle.lineSpacing;\n\n    // Pre-process text.\n    // Parse tags in the text.\n    const tagTokensNew = parseTagsNew(\n      this.text,\n      Object.keys(this.tagStyles),\n      this.options.wrapEmoji,\n      this.logWarning\n    );\n    // Assign styles to each segment.\n    const styledTokens = mapTagsToStyles(\n      tagTokensNew,\n      tagStyles,\n      spriteTemplates\n    );\n    // Measure font for each style\n    // Measure each segment\n    // Create the text segments, position and add them. (draw)\n    const newFinalTokens = calculateTokens(\n      styledTokens,\n      splitStyle,\n      scaleIcons,\n      this.options.adjustFontBaseline\n    );\n\n    this._tokens = newFinalTokens;\n    this._needsDraw = true;\n\n    // Wait one frame to draw so that this doesn't happen multiple times in one frame.\n    // if (this.animationRequest) {\n    //   window.cancelAnimationFrame(this.animationRequest);\n    // }\n    // this.animationRequest = window.requestAnimationFrame(\n\n    this.drawIfShould(skipDraw);\n\n    if (this.options.debugConsole) {\n      console.log(this.toDebugString());\n    }\n\n    this._needsUpdate = false;\n\n    return newFinalTokens;\n  }\n\n  /**\n   * Determines whether to call draw() based on the parameter and the options set then calls it or sets needsDraw to true.\n   * @param forcedSkipDraw This is the parameter provided to some functions that allow you to skip the update.\n   * It's factored in along with the defaults to figure out what to do.\n   */\n  private drawIfShould(forcedSkipDraw?: boolean): boolean {\n    if (\n      forcedSkipDraw === false ||\n      (forcedSkipDraw === undefined && this.options.skipDraw === false)\n    ) {\n      this.draw();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Create and position the display objects based on the tokens.\n   */\n  public draw(): void {\n    this.resetChildren();\n    if (this.textContainer === null || this.spriteContainer === null) {\n      throw new Error(\n        \"Somehow the textContainer or spriteContainer is null. This shouldn't be possible. Perhaps you've destroyed this object?\"\n      );\n    }\n    const textContainer = this.textContainer;\n    const spriteContainer = this.spriteContainer;\n\n    const { drawWhitespace } = this.options;\n    const tokens = drawWhitespace\n      ? this.tokensFlat\n      : // remove any tokens that are purely whitespace unless drawWhitespace is specified\n        this.tokensFlat.filter(isNotWhitespaceToken);\n\n    let drewDecorations = false;\n    let displayObject: PIXI.DisplayObject;\n\n    tokens.forEach((t) => {\n      if (isTextToken(t)) {\n        displayObject = this.createTextFieldForToken(t as TextSegmentToken);\n        textContainer.addChild(displayObject);\n        this.textFields.push(displayObject as PixiTextType);\n\n        if (t.textDecorations && t.textDecorations.length > 0) {\n          for (const d of t.textDecorations) {\n            const drawing = this.createDrawingForTextDecoration(d);\n            (displayObject as PixiTextType).addChild(drawing);\n            this._decorations.push(drawing);\n          }\n          drewDecorations = true;\n        }\n      }\n      if (isSpriteToken(t)) {\n        displayObject = t.content as PIXI.Sprite;\n\n        this.sprites.push(displayObject as PIXI.Sprite);\n        spriteContainer.addChild(displayObject);\n      }\n\n      const { bounds } = t;\n      displayObject.x = bounds.x;\n      displayObject.y = bounds.y;\n    });\n\n    if (drawWhitespace === false && drewDecorations) {\n      this.logWarning(\n        \"text-decoration-and-whitespace\",\n        \"Text decorations, such as underlines, will not appear under whitespace unless the `drawWhitespace` option is set to `true`.\"\n      );\n    }\n\n    if (this.options.debug) {\n      this.drawDebug();\n    }\n    this._needsDraw = false;\n  }\n\n  private createDrawingForTextDecoration(\n    textDecoration: TextDecorationMetrics\n  ): PIXI.Graphics {\n    const { overdrawDecorations: overdraw = 0 } = this.options;\n    const { bounds } = textDecoration;\n    let { color } = textDecoration;\n    const drawing = new PIXI.Graphics();\n\n    if (typeof color === \"string\") {\n      if (color.indexOf(\"#\") === 0) {\n        color = \"0x\" + color.substring(1);\n        color = parseInt(color, 16) as number;\n      } else {\n        this.logWarning(\n          \"invalid-color\",\n          \"Sorry, at this point, only hex colors are supported for textDecorations like underlines. Please use either a hex number like 0x66FF33 or a string like '#66FF33'\"\n        );\n      }\n    }\n\n    // the min , max here prevents the overdraw from producing a negative width drawing.\n    const { y, height } = bounds;\n    const midpoint = bounds.x + bounds.width / 2;\n    const x = Math.min(bounds.x - overdraw, midpoint);\n    const width = Math.max(bounds.width + overdraw * 2, 0);\n\n    drawing\n      .beginFill(color as number)\n      .drawRect(x, y, width, height)\n      .endFill();\n\n    return drawing;\n  }\n  \n  // ----- Customizable logic for PIXI.BitmapText and PIXI.BitmapFont: -----\n\n  /**\n   * Create a text field for an individual token (word or character).\n   *\n   * By default this generates a `BitmapFont` as necessary.\n   * \n   *\n   * @see {getOrCreateBitmapFont(style)}\n   * @see {getUniqueNameForGeneratedBitmapFont(style)}\n   * @see {getStyleOverridesForGeneratedBitmapFont(style)}\n   * @see {mapTextStylesToSupportedBitmapTextStyles(style)}\n   */\n  protected createTextField(token: TextSegmentToken, text: string, style: Partial<PIXI.ITextStyle>): PixiTextType {\n    const fontName = this._bitmapTextBehavior === 'disabled' ? undefined : this.getOrCreateBitmapFont(style);\n\n    if (!fontName) {\n      // Either bitmap text is disabled, or we did not\n      // have a bitmap font loaded for this text section.\n      return new PIXI.Text(text, style);\n    }\n\n    return new PIXI.BitmapText(text, {\n      fontName,\n      // Some style attributes can be automatically mapped to pre-generated font, for example\n      // if you wanted to change the color tint, or alignment of a font which was loaded via a file.\n      ...this.getDynamicBitmapTextStyleFromTextStyle(style),\n    });\n  }\n\n  /**\n   * Loads an existing `BitmapFont`.\n   * Generates a new BitmapFont on demand.\n   *\n   * 🚨 Caution: This will block the main thread while uploading to the GPU.\n   *\n   * @returns The `fontName` to be loaded in `new PIXI.BitmapText(text, options)`. Returns undefined if no bitmap font exists and we didn't generate one.\n   */\n  protected getOrCreateBitmapFont(style: Partial<PIXI.ITextStyle>): string | undefined {\n    if (typeof style.fontFamily === 'string') {\n      if (style.fontFamily in PIXI.BitmapFont.available) {\n        // Prefer an explitly named font if we have preloaded it.\n        // 🚨 Caution: This will disregard most of `style`.\n        return style.fontFamily;\n      }\n      else if (this._bitmapTextBehavior === 'prefer') {\n        return undefined;\n      }\n    }\n\n    // Give the font a unique, deterministic name.\n    const fontName = this.getGeneratedBitmapFontName(style);\n\n    // Generate, if it doesn't already exist.\n    if (!(fontName in PIXI.BitmapFont.available)) {\n      const [generatedTextStyle, generatedBitmapFontOptions] = this.getConfigForGeneratedBitmapFont(fontName, style);\n      PIXI.BitmapFont.from(fontName, generatedTextStyle, generatedBitmapFontOptions);\n    }\n\n    return fontName;\n  }\n\n  /**\n   * Get a deterministic, unique name for a generated font.\n   *\n   * By default, generates a semi-unique name based on the given style. Some attributes (specifically\n   * 'align', 'fontSize', 'fill', 'letterSpacing', and 'wordWrapWidth') are not included in the\n   * unique hash as they can be dynamically set in `this.mapTextStylesToSupportedBitmapTextStyles(...)`.\n   * \n   * @returns e.g. \"times-new-roman-53384123\"\n   * @see {mapSupportedDynamicBitmapTextStyles()}\n   */\n  protected getGeneratedBitmapFontName(style: Partial<PIXI.ITextStyle>): string {\n    const prefix = typeof style.fontFamily !== 'string' ? 'font' : style.fontFamily.toLowerCase().replace(/[^a-zA-Z0-9_]/gi, '-');\n\n    const strippedAttrs: (keyof PIXI.ITextStyle)[] = ['align', 'fontSize', 'fill', 'letterSpacing', 'wordWrapWidth'];\n    const _style: Partial<PIXI.ITextStyle> = { ...style };\n\n    for (const attr of strippedAttrs) {\n      delete _style[attr];\n    }\n  \n    return `${prefix}-${Math.abs(_hashCode(_style))}`;\n  }\n\n  /**\n   * Use this to set the text style and bitmap font options for a font that is about to be generated.\n   * \n   * i.e. you may want to force a minimum font size, or set the font color to 'white' so you can tint text later.\n   *\n   * By default, returns the given style, and `TaggedText.DEFAULT_BITMAP_FONT_OPTIONS`.\n   */\n  protected getConfigForGeneratedBitmapFont(fontName: string, style: Partial<PIXI.ITextStyle>): [style: Partial<PIXI.ITextStyle>, bitmapFontOptions: PIXI.IBitmapFontOptions] {\n    return [style, this._bitmapFontOptions];\n  }\n\n  /**\n   * Set which `IBitmapTextStyle` are dynamically configured from the `ITextStyle` on BitmapText, overriding the defaults from `PIXI.BitmapFont`.\n   *\n   * For example if you generated a font at 128px, you might set `{ fontSize: 64 }`.\n   *\n   * By default, the following attributes are automatically mapped to their best equivalents: 'align', 'fontSize', 'fill', 'letterSpacing', and 'wordWrapWidth'.\n   */\n  protected getDynamicBitmapTextStyleFromTextStyle(style: Partial<PIXI.ITextStyle>): Partial<PIXI.IBitmapTextStyle> {\n    return {\n      fontSize: typeof style.fontSize === 'number' ? style.fontSize : undefined,\n      letterSpacing: style.letterSpacing ?? 0,\n      maxWidth: style.wordWrapWidth ?? undefined,\n      align: style.align ?? undefined,\n      tint: (style.fill ?? 0xFFFFFF) as number | undefined, // NOTE: Color types are different in different versions of PIXI 6 and PIXI 7+.\n    };\n  }\n\n  // ----- End: Customizable logic -----\n\n  private createTextFieldForToken(token: TextSegmentToken): PixiTextType {\n    const { textTransform = \"\" } = token.style;\n\n    let text = token.content;\n    switch (textTransform.toLowerCase()) {\n      case \"lowercase\":\n        text = text.toLowerCase();\n        break;\n      case \"uppercase\":\n        text = text.toUpperCase();\n        break;\n      case \"capitalize\":\n        text = capitalize(text);\n        break;\n      default:\n    }\n\n    const alignClassic = convertUnsupportedAlignment(token.style.align);\n    const sanitizedStyle = { ...token.style, align: alignClassic };\n\n    const textField = this.createTextField(token, text, sanitizedStyle);\n\n    let { fontScaleWidth = 1.0, fontScaleHeight = 1.0 } = token.style;\n    fontScaleWidth =\n      isNaN(fontScaleWidth) || fontScaleWidth < 0 ? 0 : fontScaleWidth;\n    fontScaleHeight =\n      isNaN(fontScaleHeight) || fontScaleHeight < 0 ? 0 : fontScaleHeight;\n\n    let finalScaleWidth = fontScaleWidth;\n    let finalScaleHeight = fontScaleHeight;\n    const largerScale = Math.max(fontScaleWidth, fontScaleHeight);\n\n    if (largerScale > 1) {\n      if (largerScale === fontScaleHeight) {\n        finalScaleWidth /= largerScale;\n        finalScaleHeight = 1.0;\n      } else {\n        finalScaleHeight /= largerScale;\n        finalScaleWidth = 1.0;\n      }\n\n      const fs = textField instanceof PIXI.Text ? textField.style.fontSize ?? 0 : textField.fontSize;\n      const fontSizePx =\n        (typeof fs === \"string\" ? fontSizeStringToNumber(fs) : fs) *\n        largerScale;\n\n      if (textField instanceof PIXI.Text) {\n        textField.style.fontSize = fontSizePx;\n      } else {\n        textField.fontSize = fontSizePx;\n      }\n    }\n\n    textField.scale.set(finalScaleWidth, finalScaleHeight);\n    return textField;\n  }\n\n  /**\n   * Converts the text properties from this.tokens into a human readable string.\n   * This is automatically logged to the console on update when debug option is set to true.\n   */\n  public toDebugString(): string {\n    const lines = this.tokens;\n    let s = this.untaggedText + \"\\n=====\\n\";\n    const nl = \"\\n    \";\n    if (lines !== undefined) {\n      s += lines.map((line, lineNumber) =>\n        line.map((word, wordNumber) =>\n          word\n            .map((token, tokenNumber) => {\n              let text = \"\";\n              if (isTextToken(token)) {\n                if (isNewlineToken(token)) {\n                  text = `\\\\n`;\n                } else {\n                  text = `\"${token.content}\"`;\n                }\n              } else if (isSpriteToken(token)) {\n                text = `[Image]`;\n              }\n              let s = `\\n${text}: (${lineNumber}/${wordNumber}/${tokenNumber})`;\n              s += `${nl}tags: ${\n                token.tags.length === 0\n                  ? \"<none>\"\n                  : token.tags\n                      .split(\",\")\n                      .map((tag) => `<${tag}>`)\n                      .join(\", \")\n              }`;\n              s += `${nl}style: ${Object.entries(token.style)\n                .map((e) => e.join(\":\"))\n                .join(\"; \")}`;\n              s += `${nl}size: x:${token.bounds.x} y:${token.bounds.y} width:${\n                token.bounds.width\n              } height:${token.bounds.height} bottom:${\n                token.bounds.height + token.bounds.y\n              } right:${token.bounds.x + token.bounds.width}`;\n              s += `${nl}font: fontSize:${token.fontProperties.fontSize} ascent:${token.fontProperties.ascent} descent:${token.fontProperties.descent}`;\n              return s;\n            })\n            .join(\"\\n\")\n        )\n      );\n    }\n    return s;\n  }\n\n  public drawDebug(): void {\n    const paragraph = this.tokens;\n    this._debugGraphics = new PIXI.Graphics();\n    if (this.debugContainer === null) {\n      throw new Error(\n        \"Somehow the debug container is null. This shouldn't be possible. Perhaps you've destroyed this object?\"\n      );\n    }\n    const debugContainer = this.debugContainer;\n    debugContainer.addChild(this._debugGraphics);\n\n    const g = this._debugGraphics;\n    g.clear();\n\n    // const { width, height } = this.getBounds();\n    // // frame shadow\n    // g.lineStyle(2, DEBUG.OUTLINE_SHADOW_COLOR, 0.5);\n    // // g.beginFill();\n    // g.drawRect(1, 1, width, height);\n    // // g.endFill();\n\n    // // frame\n    // g.lineStyle(2, DEBUG.OUTLINE_COLOR, 1);\n    // // g.beginFill();\n    // g.drawRect(0, 0, width - 1, height - 1);\n    // // g.endFill();\n\n    function createInfoText(text: string, position: Point): PIXI.Text {\n      const info = new PIXI.Text(text, DEBUG.TEXT_STYLE);\n      info.x = position.x + 1;\n      info.y = position.y + 1;\n      return info;\n    }\n\n    // for (const line of tokens) {\n    for (let lineNumber = 0; lineNumber < paragraph.length; lineNumber++) {\n      const line = paragraph[lineNumber];\n      const lineBounds = getBoundsNested(line);\n\n      if (this.defaultStyle.wordWrap) {\n        const w = this.defaultStyle.wordWrapWidth ?? this.width;\n        g.endFill()\n          .lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\n          .drawRect(0, lineBounds.y, w, lineBounds.height)\n          .endFill();\n      }\n\n      for (let wordNumber = 0; wordNumber < line.length; wordNumber++) {\n        const word = line[wordNumber];\n        for (const segmentToken of word) {\n          const isSprite = isSpriteToken(segmentToken);\n          const { x, y, width } = segmentToken.bounds;\n          const baseline =\n            y +\n            (isSprite\n              ? segmentToken.bounds.height\n              : segmentToken.fontProperties.ascent);\n\n          let { height } = segmentToken.bounds;\n          if (isSprite) {\n            height += segmentToken.fontProperties.descent;\n          }\n\n          if (\n            isWhitespaceToken(segmentToken) &&\n            this.options.drawWhitespace === false\n          ) {\n            g.lineStyle(1, DEBUG.WHITESPACE_STROKE_COLOR, 1).beginFill(\n              DEBUG.WHITESPACE_COLOR,\n              0.2\n            );\n          } else {\n            g.lineStyle(1, DEBUG.WORD_STROKE_COLOR, 1).beginFill(\n              DEBUG.WORD_FILL_COLOR,\n              0.2\n            );\n          }\n\n          if (isNewlineToken(segmentToken)) {\n            this.debugContainer.addChild(\n              createInfoText(\"↩︎\", { x, y: y + 10 })\n            );\n          } else {\n            g.lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\n              .drawRect(x, y, width, height)\n              .endFill()\n\n              .lineStyle(1, DEBUG.BASELINE_COLOR, 1)\n              .beginFill()\n              .drawRect(x, baseline, width, 1)\n              .endFill();\n          }\n\n          let info;\n          // info = `${token.bounds.width}⨉${token.bounds.height}`;\n          if (isTextToken(segmentToken)) {\n            // info += ` ${token.tags}`;\n            info = `${segmentToken.tags}`;\n            this.debugContainer.addChild(createInfoText(info, { x, y }));\n          }\n          // this.debugContainer.addChild(createInfoText(info, { x, y }));\n        }\n      }\n    }\n    // }\n\n    // Show the outlines of the actual text fields,\n    // not just where the tokens say they should be\n    // const fields: PIXI.Text[] = this.textFields;\n    // for (const text of fields) {\n    //   g.lineStyle(1, DEBUG.TEXT_FIELD_STROKE_COLOR, 1);\n    //   g.drawRect(text.x, text.y, text.width, text.height);\n    // }\n  }\n}\n","\"use strict\";\n\nmodule.exports = () => {\n  // https://mths.be/emoji\n  return /\\u{1F3F4}\\u{E0067}\\u{E0062}(?:\\u{E0077}\\u{E006C}\\u{E0073}|\\u{E0073}\\u{E0063}\\u{E0074}|\\u{E0065}\\u{E006E}\\u{E0067})\\u{E007F}|(?:\\u{1F9D1}\\u{1F3FF}\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D)?\\u{1F9D1}|\\u{1F469}\\u{1F3FF}\\u200D\\u{1F91D}\\u200D[\\u{1F468}\\u{1F469}])[\\u{1F3FB}-\\u{1F3FE}]|(?:\\u{1F9D1}\\u{1F3FE}\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D)?\\u{1F9D1}|\\u{1F469}\\u{1F3FE}\\u200D\\u{1F91D}\\u200D[\\u{1F468}\\u{1F469}])[\\u{1F3FB}-\\u{1F3FD}\\u{1F3FF}]|(?:\\u{1F9D1}\\u{1F3FD}\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D)?\\u{1F9D1}|\\u{1F469}\\u{1F3FD}\\u200D\\u{1F91D}\\u200D[\\u{1F468}\\u{1F469}])[\\u{1F3FB}\\u{1F3FC}\\u{1F3FE}\\u{1F3FF}]|(?:\\u{1F9D1}\\u{1F3FC}\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D)?\\u{1F9D1}|\\u{1F469}\\u{1F3FC}\\u200D\\u{1F91D}\\u200D[\\u{1F468}\\u{1F469}])[\\u{1F3FB}\\u{1F3FD}-\\u{1F3FF}]|(?:\\u{1F9D1}\\u{1F3FB}\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D)?\\u{1F9D1}|\\u{1F469}\\u{1F3FB}\\u200D\\u{1F91D}\\u200D[\\u{1F468}\\u{1F469}])[\\u{1F3FC}-\\u{1F3FF}]|\\u{1F468}(?:\\u{1F3FB}(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D\\u{1F468}[\\u{1F3FB}-\\u{1F3FF}]|\\u{1F468}[\\u{1F3FB}-\\u{1F3FF}])|\\u{1F91D}\\u200D\\u{1F468}[\\u{1F3FC}-\\u{1F3FF}]|[\\u2695\\u2696\\u2708]\\uFE0F|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]))?|[\\u{1F3FC}-\\u{1F3FF}]\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D\\u{1F468}[\\u{1F3FB}-\\u{1F3FF}]|\\u{1F468}[\\u{1F3FB}-\\u{1F3FF}])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D)?\\u{1F468}|[\\u{1F468}\\u{1F469}]\\u200D(?:\\u{1F466}\\u200D\\u{1F466}|\\u{1F467}\\u200D[\\u{1F466}\\u{1F467}])|\\u{1F466}\\u200D\\u{1F466}|\\u{1F467}\\u200D[\\u{1F466}\\u{1F467}]|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F3FF}\\u200D(?:\\u{1F91D}\\u200D\\u{1F468}[\\u{1F3FB}-\\u{1F3FE}]|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F3FE}\\u200D(?:\\u{1F91D}\\u200D\\u{1F468}[\\u{1F3FB}-\\u{1F3FD}\\u{1F3FF}]|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F3FD}\\u200D(?:\\u{1F91D}\\u200D\\u{1F468}[\\u{1F3FB}\\u{1F3FC}\\u{1F3FE}\\u{1F3FF}]|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F3FC}\\u200D(?:\\u{1F91D}\\u200D\\u{1F468}[\\u{1F3FB}\\u{1F3FD}-\\u{1F3FF}]|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|(?:\\u{1F3FF}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FE}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FD}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FC}\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:[\\u{1F468}\\u{1F469}]\\u200D[\\u{1F466}\\u{1F467}]|[\\u{1F466}\\u{1F467}])|\\u{1F3FF}|\\u{1F3FE}|\\u{1F3FD}|\\u{1F3FC})?|(?:\\u{1F469}(?:\\u{1F3FB}\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D[\\u{1F468}\\u{1F469}]|[\\u{1F468}\\u{1F469}])|[\\u{1F3FC}-\\u{1F3FF}]\\u200D\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D[\\u{1F468}\\u{1F469}]|[\\u{1F468}\\u{1F469}]))|\\u{1F9D1}[\\u{1F3FB}-\\u{1F3FF}]\\u200D\\u{1F91D}\\u200D\\u{1F9D1})[\\u{1F3FB}-\\u{1F3FF}]|\\u{1F469}\\u200D\\u{1F469}\\u200D(?:\\u{1F466}\\u200D\\u{1F466}|\\u{1F467}\\u200D[\\u{1F466}\\u{1F467}])|\\u{1F469}(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\u{1F48B}\\u200D[\\u{1F468}\\u{1F469}]|[\\u{1F468}\\u{1F469}])|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F3FF}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FE}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FD}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FC}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FB}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F9D1}(?:\\u200D(?:\\u{1F91D}\\u200D\\u{1F9D1}|[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F384}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F3FF}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F384}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FE}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F384}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FD}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F384}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FC}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F384}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}]|\\u{1F3FB}\\u200D[\\u{1F33E}\\u{1F373}\\u{1F37C}\\u{1F384}\\u{1F393}\\u{1F3A4}\\u{1F3A8}\\u{1F3EB}\\u{1F3ED}\\u{1F4BB}\\u{1F4BC}\\u{1F527}\\u{1F52C}\\u{1F680}\\u{1F692}\\u{1F9AF}-\\u{1F9B3}\\u{1F9BC}\\u{1F9BD}])|\\u{1F469}\\u200D\\u{1F466}\\u200D\\u{1F466}|\\u{1F469}\\u200D\\u{1F469}\\u200D[\\u{1F466}\\u{1F467}]|\\u{1F469}\\u200D\\u{1F467}\\u200D[\\u{1F466}\\u{1F467}]|(?:\\u{1F441}\\uFE0F\\u200D\\u{1F5E8}|\\u{1F9D1}(?:\\u{1F3FF}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FE}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FD}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FC}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FB}\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\u{1F469}(?:\\u{1F3FF}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FE}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FD}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FC}\\u200D[\\u2695\\u2696\\u2708]|\\u{1F3FB}\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\u{1F636}\\u200D\\u{1F32B}|\\u{1F3F3}\\uFE0F\\u200D\\u26A7|\\u{1F43B}\\u200D\\u2744|(?:[\\u{1F3C3}\\u{1F3C4}\\u{1F3CA}\\u{1F46E}\\u{1F470}\\u{1F471}\\u{1F473}\\u{1F477}\\u{1F481}\\u{1F482}\\u{1F486}\\u{1F487}\\u{1F645}-\\u{1F647}\\u{1F64B}\\u{1F64D}\\u{1F64E}\\u{1F6A3}\\u{1F6B4}-\\u{1F6B6}\\u{1F926}\\u{1F935}\\u{1F937}-\\u{1F939}\\u{1F93D}\\u{1F93E}\\u{1F9B8}\\u{1F9B9}\\u{1F9CD}-\\u{1F9CF}\\u{1F9D4}\\u{1F9D6}-\\u{1F9DD}][\\u{1F3FB}-\\u{1F3FF}]|[\\u{1F46F}\\u{1F93C}\\u{1F9DE}\\u{1F9DF}])\\u200D[\\u2640\\u2642]|[\\u26F9\\u{1F3CB}\\u{1F3CC}\\u{1F575}][\\uFE0F\\u{1F3FB}-\\u{1F3FF}]\\u200D[\\u2640\\u2642]|\\u{1F3F4}\\u200D\\u2620|[\\u{1F3C3}\\u{1F3C4}\\u{1F3CA}\\u{1F46E}\\u{1F470}\\u{1F471}\\u{1F473}\\u{1F477}\\u{1F481}\\u{1F482}\\u{1F486}\\u{1F487}\\u{1F645}-\\u{1F647}\\u{1F64B}\\u{1F64D}\\u{1F64E}\\u{1F6A3}\\u{1F6B4}-\\u{1F6B6}\\u{1F926}\\u{1F935}\\u{1F937}-\\u{1F939}\\u{1F93D}\\u{1F93E}\\u{1F9B8}\\u{1F9B9}\\u{1F9CD}-\\u{1F9CF}\\u{1F9D4}\\u{1F9D6}-\\u{1F9DD}]\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299\\u{1F170}\\u{1F171}\\u{1F17E}\\u{1F17F}\\u{1F202}\\u{1F237}\\u{1F321}\\u{1F324}-\\u{1F32C}\\u{1F336}\\u{1F37D}\\u{1F396}\\u{1F397}\\u{1F399}-\\u{1F39B}\\u{1F39E}\\u{1F39F}\\u{1F3CD}\\u{1F3CE}\\u{1F3D4}-\\u{1F3DF}\\u{1F3F5}\\u{1F3F7}\\u{1F43F}\\u{1F4FD}\\u{1F549}\\u{1F54A}\\u{1F56F}\\u{1F570}\\u{1F573}\\u{1F576}-\\u{1F579}\\u{1F587}\\u{1F58A}-\\u{1F58D}\\u{1F5A5}\\u{1F5A8}\\u{1F5B1}\\u{1F5B2}\\u{1F5BC}\\u{1F5C2}-\\u{1F5C4}\\u{1F5D1}-\\u{1F5D3}\\u{1F5DC}-\\u{1F5DE}\\u{1F5E1}\\u{1F5E3}\\u{1F5E8}\\u{1F5EF}\\u{1F5F3}\\u{1F5FA}\\u{1F6CB}\\u{1F6CD}-\\u{1F6CF}\\u{1F6E0}-\\u{1F6E5}\\u{1F6E9}\\u{1F6F0}\\u{1F6F3}])\\uFE0F|\\u{1F3F3}\\uFE0F\\u200D\\u{1F308}|\\u{1F469}\\u200D\\u{1F467}|\\u{1F469}\\u200D\\u{1F466}|\\u{1F635}\\u200D\\u{1F4AB}|\\u{1F62E}\\u200D\\u{1F4A8}|\\u{1F415}\\u200D\\u{1F9BA}|\\u{1F9D1}(?:\\u{1F3FF}|\\u{1F3FE}|\\u{1F3FD}|\\u{1F3FC}|\\u{1F3FB})?|\\u{1F469}(?:\\u{1F3FF}|\\u{1F3FE}|\\u{1F3FD}|\\u{1F3FC}|\\u{1F3FB})?|\\u{1F1FD}\\u{1F1F0}|\\u{1F1F6}\\u{1F1E6}|\\u{1F1F4}\\u{1F1F2}|\\u{1F408}\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D[\\u{1F525}\\u{1FA79}]|\\u{1F441}\\uFE0F|\\u{1F3F3}\\uFE0F|\\u{1F1FF}[\\u{1F1E6}\\u{1F1F2}\\u{1F1FC}]|\\u{1F1FE}[\\u{1F1EA}\\u{1F1F9}]|\\u{1F1FC}[\\u{1F1EB}\\u{1F1F8}]|\\u{1F1FB}[\\u{1F1E6}\\u{1F1E8}\\u{1F1EA}\\u{1F1EC}\\u{1F1EE}\\u{1F1F3}\\u{1F1FA}]|\\u{1F1FA}[\\u{1F1E6}\\u{1F1EC}\\u{1F1F2}\\u{1F1F3}\\u{1F1F8}\\u{1F1FE}\\u{1F1FF}]|\\u{1F1F9}[\\u{1F1E6}\\u{1F1E8}\\u{1F1E9}\\u{1F1EB}-\\u{1F1ED}\\u{1F1EF}-\\u{1F1F4}\\u{1F1F7}\\u{1F1F9}\\u{1F1FB}\\u{1F1FC}\\u{1F1FF}]|\\u{1F1F8}[\\u{1F1E6}-\\u{1F1EA}\\u{1F1EC}-\\u{1F1F4}\\u{1F1F7}-\\u{1F1F9}\\u{1F1FB}\\u{1F1FD}-\\u{1F1FF}]|\\u{1F1F7}[\\u{1F1EA}\\u{1F1F4}\\u{1F1F8}\\u{1F1FA}\\u{1F1FC}]|\\u{1F1F5}[\\u{1F1E6}\\u{1F1EA}-\\u{1F1ED}\\u{1F1F0}-\\u{1F1F3}\\u{1F1F7}-\\u{1F1F9}\\u{1F1FC}\\u{1F1FE}]|\\u{1F1F3}[\\u{1F1E6}\\u{1F1E8}\\u{1F1EA}-\\u{1F1EC}\\u{1F1EE}\\u{1F1F1}\\u{1F1F4}\\u{1F1F5}\\u{1F1F7}\\u{1F1FA}\\u{1F1FF}]|\\u{1F1F2}[\\u{1F1E6}\\u{1F1E8}-\\u{1F1ED}\\u{1F1F0}-\\u{1F1FF}]|\\u{1F1F1}[\\u{1F1E6}-\\u{1F1E8}\\u{1F1EE}\\u{1F1F0}\\u{1F1F7}-\\u{1F1FB}\\u{1F1FE}]|\\u{1F1F0}[\\u{1F1EA}\\u{1F1EC}-\\u{1F1EE}\\u{1F1F2}\\u{1F1F3}\\u{1F1F5}\\u{1F1F7}\\u{1F1FC}\\u{1F1FE}\\u{1F1FF}]|\\u{1F1EF}[\\u{1F1EA}\\u{1F1F2}\\u{1F1F4}\\u{1F1F5}]|\\u{1F1EE}[\\u{1F1E8}-\\u{1F1EA}\\u{1F1F1}-\\u{1F1F4}\\u{1F1F6}-\\u{1F1F9}]|\\u{1F1ED}[\\u{1F1F0}\\u{1F1F2}\\u{1F1F3}\\u{1F1F7}\\u{1F1F9}\\u{1F1FA}]|\\u{1F1EC}[\\u{1F1E6}\\u{1F1E7}\\u{1F1E9}-\\u{1F1EE}\\u{1F1F1}-\\u{1F1F3}\\u{1F1F5}-\\u{1F1FA}\\u{1F1FC}\\u{1F1FE}]|\\u{1F1EB}[\\u{1F1EE}-\\u{1F1F0}\\u{1F1F2}\\u{1F1F4}\\u{1F1F7}]|\\u{1F1EA}[\\u{1F1E6}\\u{1F1E8}\\u{1F1EA}\\u{1F1EC}\\u{1F1ED}\\u{1F1F7}-\\u{1F1FA}]|\\u{1F1E9}[\\u{1F1EA}\\u{1F1EC}\\u{1F1EF}\\u{1F1F0}\\u{1F1F2}\\u{1F1F4}\\u{1F1FF}]|\\u{1F1E8}[\\u{1F1E6}\\u{1F1E8}\\u{1F1E9}\\u{1F1EB}-\\u{1F1EE}\\u{1F1F0}-\\u{1F1F5}\\u{1F1F7}\\u{1F1FA}-\\u{1F1FF}]|\\u{1F1E7}[\\u{1F1E6}\\u{1F1E7}\\u{1F1E9}-\\u{1F1EF}\\u{1F1F1}-\\u{1F1F4}\\u{1F1F6}-\\u{1F1F9}\\u{1F1FB}\\u{1F1FC}\\u{1F1FE}\\u{1F1FF}]|\\u{1F1E6}[\\u{1F1E8}-\\u{1F1EC}\\u{1F1EE}\\u{1F1F1}\\u{1F1F2}\\u{1F1F4}\\u{1F1F6}-\\u{1F1FA}\\u{1F1FC}\\u{1F1FD}\\u{1F1FF}]|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|[\\u{1F3C3}\\u{1F3C4}\\u{1F3CA}\\u{1F46E}\\u{1F470}\\u{1F471}\\u{1F473}\\u{1F477}\\u{1F481}\\u{1F482}\\u{1F486}\\u{1F487}\\u{1F645}-\\u{1F647}\\u{1F64B}\\u{1F64D}\\u{1F64E}\\u{1F6A3}\\u{1F6B4}-\\u{1F6B6}\\u{1F926}\\u{1F935}\\u{1F937}-\\u{1F939}\\u{1F93D}\\u{1F93E}\\u{1F9B8}\\u{1F9B9}\\u{1F9CD}-\\u{1F9CF}\\u{1F9D4}\\u{1F9D6}-\\u{1F9DD}][\\u{1F3FB}-\\u{1F3FF}]|[\\u26F9\\u{1F3CB}\\u{1F3CC}\\u{1F575}][\\uFE0F\\u{1F3FB}-\\u{1F3FF}]|\\u{1F3F4}|[\\u270A\\u270B\\u{1F385}\\u{1F3C2}\\u{1F3C7}\\u{1F442}\\u{1F443}\\u{1F446}-\\u{1F450}\\u{1F466}\\u{1F467}\\u{1F46B}-\\u{1F46D}\\u{1F472}\\u{1F474}-\\u{1F476}\\u{1F478}\\u{1F47C}\\u{1F483}\\u{1F485}\\u{1F48F}\\u{1F491}\\u{1F4AA}\\u{1F57A}\\u{1F595}\\u{1F596}\\u{1F64C}\\u{1F64F}\\u{1F6C0}\\u{1F6CC}\\u{1F90C}\\u{1F90F}\\u{1F918}-\\u{1F91C}\\u{1F91E}\\u{1F91F}\\u{1F930}-\\u{1F934}\\u{1F936}\\u{1F977}\\u{1F9B5}\\u{1F9B6}\\u{1F9BB}\\u{1F9D2}\\u{1F9D3}\\u{1F9D5}][\\u{1F3FB}-\\u{1F3FF}]|[\\u261D\\u270C\\u270D\\u{1F574}\\u{1F590}][\\uFE0F\\u{1F3FB}-\\u{1F3FF}]|[\\u270A\\u270B\\u{1F385}\\u{1F3C2}\\u{1F3C7}\\u{1F408}\\u{1F415}\\u{1F43B}\\u{1F442}\\u{1F443}\\u{1F446}-\\u{1F450}\\u{1F466}\\u{1F467}\\u{1F46B}-\\u{1F46D}\\u{1F472}\\u{1F474}-\\u{1F476}\\u{1F478}\\u{1F47C}\\u{1F483}\\u{1F485}\\u{1F48F}\\u{1F491}\\u{1F4AA}\\u{1F57A}\\u{1F595}\\u{1F596}\\u{1F62E}\\u{1F635}\\u{1F636}\\u{1F64C}\\u{1F64F}\\u{1F6C0}\\u{1F6CC}\\u{1F90C}\\u{1F90F}\\u{1F918}-\\u{1F91C}\\u{1F91E}\\u{1F91F}\\u{1F930}-\\u{1F934}\\u{1F936}\\u{1F977}\\u{1F9B5}\\u{1F9B6}\\u{1F9BB}\\u{1F9D2}\\u{1F9D3}\\u{1F9D5}]|[\\u{1F3C3}\\u{1F3C4}\\u{1F3CA}\\u{1F46E}\\u{1F470}\\u{1F471}\\u{1F473}\\u{1F477}\\u{1F481}\\u{1F482}\\u{1F486}\\u{1F487}\\u{1F645}-\\u{1F647}\\u{1F64B}\\u{1F64D}\\u{1F64E}\\u{1F6A3}\\u{1F6B4}-\\u{1F6B6}\\u{1F926}\\u{1F935}\\u{1F937}-\\u{1F939}\\u{1F93D}\\u{1F93E}\\u{1F9B8}\\u{1F9B9}\\u{1F9CD}-\\u{1F9CF}\\u{1F9D4}\\u{1F9D6}-\\u{1F9DD}]|[\\u{1F46F}\\u{1F93C}\\u{1F9DE}\\u{1F9DF}]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55\\u{1F004}\\u{1F0CF}\\u{1F18E}\\u{1F191}-\\u{1F19A}\\u{1F201}\\u{1F21A}\\u{1F22F}\\u{1F232}-\\u{1F236}\\u{1F238}-\\u{1F23A}\\u{1F250}\\u{1F251}\\u{1F300}-\\u{1F320}\\u{1F32D}-\\u{1F335}\\u{1F337}-\\u{1F37C}\\u{1F37E}-\\u{1F384}\\u{1F386}-\\u{1F393}\\u{1F3A0}-\\u{1F3C1}\\u{1F3C5}\\u{1F3C6}\\u{1F3C8}\\u{1F3C9}\\u{1F3CF}-\\u{1F3D3}\\u{1F3E0}-\\u{1F3F0}\\u{1F3F8}-\\u{1F407}\\u{1F409}-\\u{1F414}\\u{1F416}-\\u{1F43A}\\u{1F43C}-\\u{1F43E}\\u{1F440}\\u{1F444}\\u{1F445}\\u{1F451}-\\u{1F465}\\u{1F46A}\\u{1F479}-\\u{1F47B}\\u{1F47D}-\\u{1F480}\\u{1F484}\\u{1F488}-\\u{1F48E}\\u{1F490}\\u{1F492}-\\u{1F4A9}\\u{1F4AB}-\\u{1F4FC}\\u{1F4FF}-\\u{1F53D}\\u{1F54B}-\\u{1F54E}\\u{1F550}-\\u{1F567}\\u{1F5A4}\\u{1F5FB}-\\u{1F62D}\\u{1F62F}-\\u{1F634}\\u{1F637}-\\u{1F644}\\u{1F648}-\\u{1F64A}\\u{1F680}-\\u{1F6A2}\\u{1F6A4}-\\u{1F6B3}\\u{1F6B7}-\\u{1F6BF}\\u{1F6C1}-\\u{1F6C5}\\u{1F6D0}-\\u{1F6D2}\\u{1F6D5}-\\u{1F6D7}\\u{1F6EB}\\u{1F6EC}\\u{1F6F4}-\\u{1F6FC}\\u{1F7E0}-\\u{1F7EB}\\u{1F90D}\\u{1F90E}\\u{1F910}-\\u{1F917}\\u{1F91D}\\u{1F920}-\\u{1F925}\\u{1F927}-\\u{1F92F}\\u{1F93A}\\u{1F93F}-\\u{1F945}\\u{1F947}-\\u{1F976}\\u{1F978}\\u{1F97A}-\\u{1F9B4}\\u{1F9B7}\\u{1F9BA}\\u{1F9BC}-\\u{1F9CB}\\u{1F9D0}\\u{1F9E0}-\\u{1F9FF}\\u{1FA70}-\\u{1FA74}\\u{1FA78}-\\u{1FA7A}\\u{1FA80}-\\u{1FA86}\\u{1FA90}-\\u{1FAA8}\\u{1FAB0}-\\u{1FAB6}\\u{1FAC0}-\\u{1FAC2}\\u{1FAD0}-\\u{1FAD6}]/gu;\n};\n"],"names":["MeasurementUnit","combineRecords","a","b","_extends","last","length","isDefined","undefined","flatReduce","f","acc","nested","flat","reduce","flatEvery","p","t","logWarning","handler","supressConsole","target","code","message","type","console","warn","isSpriteSource","s","PIXI","Texture","HTMLCanvasElement","HTMLVideoElement","IMG_REFERENCE_PROPERTY","IMG_DISPLAY_PROPERTY","DEFAULT_KEY","predicate","group","any","_DEFAULT_STYLE","DEFAULT_MEASUREMENT_UNIT","createEmptySegmentToken","content","bounds","Rectangle","fontProperties","ascent","descent","fontSize","style","tags","textDecorations","isWhitespace","split","every","char","search","isSpriteToken","Sprite","_isTextToken","isTextToken","isWhitespaceToken","_isNewlineToken","isNewlineToken","isNotWhitespaceToken","input","isEmptyObject","Object","keys","measurementValueToComponents","Error","value","unit","trim","pattern","RegExp","values","join","i","parseFloat","slice","forcedNumberConversion","isNaN","NaN","unknown","defaultLogWarning","getTagRegex","tagNamesToMatch","captureGroup","TAG_NAMES","ATTRIBUTES","noCaptureGroup","TAG_OPEN","EMOJI_TAG","parseAttributes","attributesString","attributes","match","concat","obj","attribute","attributePair","substring","indexOf","name","valueStr","createTagMatchData","openTagName","index","tag","tagName","isOpening","selfClosingTagSearch","call","arguments","not","TAG_SLASH","tagMatchToTagToken","children","capitalize","str","chars","converted","charAt","toUpperCase","substr","isOnlyWhitespace","DEFAULT_STYLE","valign","dropShadowColor","fill","stroke","wordWrap","wordWrapWidth","iconScale","breakLines","freeze","combineStyles","combineAllStyles","styles","filter","getStyleForTag","tagStyles","_injectAttributes","convertedAttributes","key","isStringNumber","convertAttributeValues","injectAttributes","convertUnsupportedAlignment","align","measureFont","context","TextMetrics","font","getFontPropertiesOfText","textField","forceUpdate","updateText","_textField$style$font","props","fs","Number","sizer","Text","translateLine","offset","line","map","point","x","y","translatePoint","lineWidth","wordsInLine","firstWord","lastWord","width","setBoundsX","object","_extends2","positionWordX","word","prevBounds","token","concatBounds","originalBounds","height","Math","min","max","getBoundsNested","alignLeft","newLine","alignRight","maxWidth","alignCenter","alignJustify","maxLineWidth","nonZeroWidthWords","_ref","countNonZeroWidthWords","first","rest","previousWord","result","combinedBounds","getCombinedBounds","spacerWidth","newWord","getTallestToken","tallest","current","_current$bounds$heigh","_tallest$bounds$heigh","h","notEmptyString","SPLIT_MARKER","splitAroundWhitespace","replace","DEFAULT_OPTIONS","debug","debugConsole","splitStyle","imgMap","scaleIcons","skipUpdates","skipDraw","drawWhitespace","wrapEmoji","errorHandler","overdrawDecorations","DEBUG","fontFamily","dropShadow","DEFAULT_STYLE_SET","default","DEFAULT_DESTROY_OPTIONS","texture","TaggedText","_PIXI$Sprite","text","options","bitmapFontOptions","bitmapTextBehavior","_this","_bitmapFontOptions","_bitmapTextBehavior","_options","_needsUpdate","_needsDraw","_tokens","_text","_tagStyles","_textFields","_sprites","_decorations","_spriteTemplates","_debugGraphics","_textContainer","_decorationContainer","_spriteContainer","_debugContainer","_logWarning","Container","Graphics","DEFAULT_BITMAP_FONT_OPTIONS","DEFAULT_BITMAP_TEXT_BEHAVIOR","resetChildren","mergedOptions","mergedDefaultStyles","createSpriteTemplatesFromSourceMap","_proto","prototype","_createClass","setText","skipUpdate","this","updateIfShould","setTagStyles","_this2","entries","forEach","setStyleForTag","getStyleForTagExt","getStyleForTags","_this3","_ref2","defaultStyle","removeStylesForTag","setDefaultStyle","defaultStyles","destroyImgMap","destroyed","destroy","baseTexture","destroyOptions","removeChildren","removeChild","addChild","_this4","_ref3","_sprite$texture","_this4$getStyleForTag","spriteSource","wrongFormatError","TypeError","destroyedError","error","sprite","from","HTMLImageElement","isImageElement","BaseTexture","isBaseTexture","log","e","addListener","onTextureUpdate","onImageTextureUpdate","removeListener","spriteTemplates","existingStyle","forcedSkipUpdate","update","_this$options","styledTokens","tokens","_styles$default","tagStack","fontSizeStack","styleCache","convertTagTokenToStyledToken","_fontSizeStack","_style$IMG_REFERENCE_","_measurementValueToCo","baseValue","baseUnit","_measurementValueToCo2","objects","_token$attributes","currentBaseFontSize","push","o","tagHash","JSON","stringify","tagWithAttributesToStyle","stylesWithDefault","textDecoration","defaultColor","decorationColor","defaultThickness","decorationThickness","mergeDecoration","decorationLineType","decorationLineTypeCamelCase","_style$textDecoration","_style","_style2","_style3","includes","convertDecorationToLineProps","percent","currentTagStyle","color","styledToken","imgKey","pop","mapTagsToStyles","shouldWrapEmoji","logWarningFunction","test","containsEmoji","emojiRegex","source","replaceAll","tagStart","_","output","replaceSelfClosingTags","re","tagMatches","exec","tagMatch","segments","rootTokens","tokenStack","_segments","segment","poppedToken","createTokensNew","tagMatchData","_step","remaining","_iterator","_createForOfIteratorHelperLoose","done","startOfTag","endOfTag","extractSegments","parseTagsNew","newFinalTokens","adjustFontBaseline","_defaultStyle$lineSpa","_defaultStyle$align","finalTokens","flatMap","generateTokensFormStyledToken","alignClassic","dropShadowBlur","dropShadowDistance","dropShadowAngle","textSegments","suggestion","badStyle","toLowerCase","splitText","textTokens","_style$fontScaleWidth","_style$fontScaleHeigh","textTransform","_sizer$style$strokeTh","strokeThickness","sw","fontScaleWidth","sh","fontScaleHeight","scaleWidth","scaleHeight","scale","set","container","textBounds","baseline","ascender","xHeight","metrics","_style4","extractDecorations","baselineAdjustment","fontBaselineMap","_style$fontFamily$toS","_style$fontFamily","_style$adjustBaseline","_fontBaselineMap$font","toString","adjustBaseline","finalValue","percentPair","isPercent","getBaselineAdjustment","letterSpacing","_style$strokeThicknes","convertedToken","isIcon","rect","_style$iconScale","_style$fontScaleWidth2","_style$fontScaleHeigh2","scaleY","newStyle","newTags","ww","www","hasWordWrapWidth","lineSpacing","cursor","wordWidth","allLines","tallestHeightInLine","normalLineBreaks","hasNormalLineBreaks","isNewline","isImage","breakWords","positionWordBufferAndAddToLine","addTokenToWordAndUpdateWordWidth","setTallestHeight","isBlockImage","addLineToListOfLinesAndMoveCursorToNextLine","addLineToListOfLines","collapsedWhitespace","lines","_step6","_iterator6","_iterator7","_step7","collapseWhitespacesOnEndOfLines","alignedLines","alignFunction","lastAlignFunction","_step2","alignedLine","isLastLine","wordBoundsForLine","_iterator2","wordBounds","alignLines","valignedLines","overrideValign","_step3","previousTallestToken","previousLineBottom","paragraphModifier","newLines","_iterator3","_tallestToken$bounds$","_tallestToken$bounds","_tallestToken$fontPro","_tallestToken$fontPro2","_tallestToken$style$p","tallestToken","tallestHeight","tallestAscent","valignParagraphModifier","paragraphSpacing","_iterator4","_step4","_step5","_iterator5","newBounds","newToken","newY","verticalAlignInLines","_token$fontProperties","_token$fontProperties2","_token$bounds$height","_token$bounds","positionTokenAtCursorAndAdvanceCursor","_token$style$breakLin","layout","POSITIVE_INFINITY","calculateTokens","drawIfShould","toDebugString","forcedSkipDraw","draw","_this5","textContainer","spriteContainer","displayObject","tokensFlat","drewDecorations","createTextFieldForToken","textFields","drawing","createDrawingForTextDecoration","sprites","drawDebug","_this$options$overdra","overdraw","parseInt","beginFill","drawRect","endFill","createTextField","fontName","getOrCreateBitmapFont","BitmapText","getDynamicBitmapTextStyleFromTextStyle","BitmapFont","available","getGeneratedBitmapFontName","_this$getConfigForGen","getConfigForGeneratedBitmapFont","generatedBitmapFontOptions","prefix","_i","_strippedAttrs","abs","sort","hash","len","charCodeAt","_hashCode","_style$letterSpacing","_style$wordWrapWidth","_style$align","_style$fill","tint","_token$style$textTran","sanitizedStyle","_token$style","_token$style$fontScal","_token$style$fontScal2","finalScaleWidth","finalScaleHeight","largerScale","fontSizePx","size","_size$split","fontSizeStringToNumber","untaggedText","nl","lineNumber","wordNumber","tokenNumber","paragraph","debugContainer","g","createInfoText","position","info","clear","lineBounds","_this$defaultStyle$wo","w","lineStyle","segmentToken","isSprite","_segmentToken$bounds","get","_this$tagStyles","ASCII","resolution","window","devicePixelRatio"],"mappings":"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"}